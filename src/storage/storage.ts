/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 * Hasura Storage
 * Hasura Storage is amazing
 * OpenAPI spec version: 1.0.0
 */
import Axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse,
  CreateAxiosDefaults
} from 'axios';

export interface VersionInformation {
  buildVersion?: string;
}

export interface FileSummary {
  id?: string;
  name?: string;
  bucketId?: string;
  isUploaded?: boolean;
}

export type FileMetadataMetadata = { [key: string]: unknown };

export interface FileMetadata {
  id?: string;
  name?: string;
  size?: number;
  bucketId?: string;
  eTag?: string;
  createdAt?: string;
  updatedAt?: string;
  isUploaded?: boolean;
  mimeType?: string;
  uploadedByUserId?: string;
  metadata?: FileMetadataMetadata;
}

export type UploadFileMetadataMetadata = { [key: string]: unknown };

export interface UploadFileMetadata {
  id?: string;
  name?: string;
  metadata?: UploadFileMetadataMetadata;
}

export type UpdateFileMetadataMetadata = { [key: string]: unknown };

export interface UpdateFileMetadata {
  name?: string;
  metadata?: UpdateFileMetadataMetadata;
}

export interface PresignedURLResponse {
  url?: string;
  expiration?: number;
}

export type ErrorError = {
  message?: string;
};

export interface Error {
  error?: ErrorError;
}

export type GetOpenapiYaml200 = { [key: string]: unknown };

export type PostFilesBody = {
  /** Bucket to upload the files to */
  'bucket-id'?: string;
  /** (Optional) Set the following metadata for the uploaded files instead of letting the server do it automatically. See "UploadFileMetadata". */
  'metadata[]'?: UploadFileMetadata[];
  /** Array of files to upload. */
  'file[]'?: Blob[];
};

export type PostFiles201 = {
  ProcessedFiles?: FileMetadata[];
};

export type HeadFilesIdParams = {
/**
 * Quality of the image. Only applies to jpeg, webp and png files
 */
q?: number;
/**
 * Resize image up to h maintaining aspect ratio. Only applies to jpeg, webp and png files
 */
h?: number;
/**
 * Resize image up to w maintaining aspect ratio. Only applies to jpeg, webp and png files
 */
w?: number;
/**
 * Blur the image according to this sigma value. Only applies to jpeg, webp and png files
 */
b?: number;
/**
 * Format to output the image in. Only applies to images. If `same` the image will be returned in the same format as it was uploaded. If `auto` the server will choose the first match in the Accept header from the client following the order `avif`, `webp`, `jpeg`, `png`.
 */
f?: HeadFilesIdF;
};

export type HeadFilesIdF = typeof HeadFilesIdF[keyof typeof HeadFilesIdF];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HeadFilesIdF = {
  auto: 'auto',
  same: 'same',
  jpeg: 'jpeg',
  webp: 'webp',
  png: 'png',
  avif: 'avif',
} as const;

export type GetFilesIdParams = {
/**
 * Quality of the image. Only applies to jpeg, webp and png files
 */
q?: number;
/**
 * Resize image up to h maintaining aspect ratio. Only applies to jpeg, webp and png files
 */
h?: number;
/**
 * Resize image up to w maintaining aspect ratio. Only applies to jpeg, webp and png files
 */
w?: number;
/**
 * Blur the image according to this sigma value. Only applies to jpeg, webp and png files
 */
b?: number;
};

export type PutFilesIdBody = {
  metadata?: UpdateFileMetadata;
  /** New contents of the file to upload. */
  file?: unknown;
};

export type GetFilesIdPresignedurlContentsParams = {
/**
 * Use presignedurl endpoint to generate this automatically
 */
'X-Amz-Algorithm': string;
/**
 * Use presignedurl endpoint to generate this automatically
 */
'X-Amz-Credential': string;
/**
 * Use presignedurl endpoint to generate this automatically
 */
'X-Amz-Date': string;
/**
 * Use presignedurl endpoint to generate this automatically
 */
'X-Amz-Expires': string;
/**
 * Use presignedurl endpoint to generate this automatically
 */
'X-Amz-Signature': string;
/**
 * Use presignedurl endpoint to generate this automatically
 */
'X-Amz-SignedHeaders': string;
/**
 * Quality of the image. Only applies to jpeg, webp and png files
 */
q?: number;
/**
 * Resize image up to h maintaining aspect ratio. Only applies to jpeg, webp and png files
 */
h?: number;
/**
 * Resize image up to w maintaining aspect ratio. Only applies to jpeg, webp and png files
 */
w?: number;
/**
 * Blur the image according to this sigma value. Only applies to jpeg, webp and png files
 */
b?: number;
};

export type PostOpsListOrphans200 = {
  files?: string[];
};

export type PostOpsDeleteOrphans200 = {
  files?: string[];
};

export type PostOpsListBrokenMetadata200 = {
  metadata?: FileSummary[];
};

export type PostOpsDeleteBrokenMetadata200 = {
  metadata?: FileSummary[];
};

export type PostOpsListNotUploaded200 = {
  metadata?: FileSummary[];
};

export const createApiClient = (config?: CreateAxiosDefaults) => {
  const axios = Axios.create(config);
/**
 * @summary Return this schema definition
 */
const getOpenapiYaml = <TData = AxiosResponse<GetOpenapiYaml200>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/openapi.yaml`,options
    );
  }

/**
 * @summary Retrieve build information about the server
 */
const getVersion = <TData = AxiosResponse<VersionInformation>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/version`,options
    );
  }

/**
 * You can upload more than one file by sending several file[]. Sending the metadata[] for files is optional but if you are uploading many files you need to either specify the metadata for all or for none.
 * @summary Upload one or more files
 */
const postFiles = <TData = AxiosResponse<PostFiles201>>(
    postFilesBody: PostFilesBody, options?: AxiosRequestConfig
 ): Promise<TData> => {const formData = new FormData();
if(postFilesBody['bucket-id'] !== undefined) {
 formData.append(`bucket-id`, postFilesBody['bucket-id'])
 }
if(postFilesBody['metadata[]'] !== undefined) {
 postFilesBody['metadata[]'].forEach(value => formData.append(`metadata[]`, JSON.stringify(value)));
 }
if(postFilesBody['file[]'] !== undefined) {
 postFilesBody['file[]'].forEach(value => formData.append(`file[]`, value));
 }

    return axios.post(
      `/files/`,
      formData,options
    );
  }

/**
 * Retrieve information about a file
 * @summary Retrieve information about a file
 */
const headFilesId = <TData = AxiosResponse<void>>(
    id: string,
    params?: HeadFilesIdParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.head(
      `/files/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Retrieve contents of file
 * @summary Retrieve contents of file
 */
const getFilesId = <TData = AxiosResponse<unknown>>(
    id: string,
    params?: GetFilesIdParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/files/${id}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Replace the contents of an existing file. The workflow to replace a file is as follows:
  1. Set isUploaded flag to false
  2. Replace contents of the file in the storage backend
  3. Update file metadata (size, mime-type, isUploaded, etc)

Each individual state is atomic but if a step fails, previous steps won't be undone

 * @summary Replace an existing file with a new one
 */
const putFilesId = <TData = AxiosResponse<FileMetadata>>(
    id: string,
    putFilesIdBody: PutFilesIdBody, options?: AxiosRequestConfig
 ): Promise<TData> => {const formData = new FormData();
if(putFilesIdBody.metadata !== undefined) {
 formData.append(`metadata`, JSON.stringify(putFilesIdBody.metadata));
 }
if(putFilesIdBody.file !== undefined) {
 formData.append(`file`, putFilesIdBody.file)
 }

    return axios.put(
      `/files/${id}`,
      formData,options
    );
  }

/**
 * Delete a file
 * @summary Delete a file
 */
const deleteFilesId = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/files/${id}`,options
    );
  }

/**
 * Retrieve presigned URL to retrieve the file. Expiration of the URL is
determined by bucket configuration

 * @summary Retrieve presigned URL to retrieve the file
 */
const getFilesIdPresignedurl = <TData = AxiosResponse<PresignedURLResponse>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/files/${id}/presignedurl`,options
    );
  }

/**
 * Retrieve contents of file
 * @summary Retrieve contents of file
 */
const getFilesIdPresignedurlContents = <TData = AxiosResponse<unknown>>(
    id: string,
    params: GetFilesIdPresignedurlContentsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/files/${id}/presignedurl/contents`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Orphaned files are files that are present in the storage but have no associated metadata
 * @summary Lists orphaned files
 */
const postOpsListOrphans = <TData = AxiosResponse<PostOpsListOrphans200>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/ops/list-orphans`,undefined,options
    );
  }

/**
 * Orphaned files are files that are present in the storage but have no associated metadata
 * @summary Deletes orphaned files
 */
const postOpsDeleteOrphans = <TData = AxiosResponse<PostOpsDeleteOrphans200>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/ops/delete-orphans`,undefined,options
    );
  }

/**
 * Broken metadata is defined as metadata that has isUploaded = true but there is no file in the storage matching it
 * @summary Lists broken metadata
 */
const postOpsListBrokenMetadata = <TData = AxiosResponse<PostOpsListBrokenMetadata200>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/ops/list-broken-metadata`,undefined,options
    );
  }

/**
 * Broken metadata is defined as metadata that has isUploaded = true but there is no file in the storage matching it
 * @summary Delete broken metadata
 */
const postOpsDeleteBrokenMetadata = <TData = AxiosResponse<PostOpsDeleteBrokenMetadata200>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/ops/delete-broken-metadata`,undefined,options
    );
  }

/**
 * That is, metadata that has isUploaded = false
 * @summary Lists files that haven't been uploaded
 */
const postOpsListNotUploaded = <TData = AxiosResponse<PostOpsListNotUploaded200>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/ops/list-not-uploaded`,undefined,options
    );
  }

return {getOpenapiYaml,getVersion,postFiles,headFilesId,getFilesId,putFilesId,deleteFilesId,getFilesIdPresignedurl,getFilesIdPresignedurlContents,postOpsListOrphans,postOpsDeleteOrphans,postOpsListBrokenMetadata,postOpsDeleteBrokenMetadata,postOpsListNotUploaded}};
export type GetOpenapiYamlResult = AxiosResponse<GetOpenapiYaml200>
export type GetVersionResult = AxiosResponse<VersionInformation>
export type PostFilesResult = AxiosResponse<PostFiles201>
export type HeadFilesIdResult = AxiosResponse<void>
export type GetFilesIdResult = AxiosResponse<unknown>
export type PutFilesIdResult = AxiosResponse<FileMetadata>
export type DeleteFilesIdResult = AxiosResponse<void>
export type GetFilesIdPresignedurlResult = AxiosResponse<PresignedURLResponse>
export type GetFilesIdPresignedurlContentsResult = AxiosResponse<unknown>
export type PostOpsListOrphansResult = AxiosResponse<PostOpsListOrphans200>
export type PostOpsDeleteOrphansResult = AxiosResponse<PostOpsDeleteOrphans200>
export type PostOpsListBrokenMetadataResult = AxiosResponse<PostOpsListBrokenMetadata200>
export type PostOpsDeleteBrokenMetadataResult = AxiosResponse<PostOpsDeleteBrokenMetadata200>
export type PostOpsListNotUploadedResult = AxiosResponse<PostOpsListNotUploaded200>
