/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * Nhost Auth
 * Service to Authenticate
 * OpenAPI spec version: 1.0.0
 */
import Axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse,
  CreateAxiosDefaults
} from 'axios';

export interface JWKSet {
  keys: Jwk[];
}

export interface Jwk {
  alg: string;
  e: string;
  kid: string;
  kty: string;
  n: string;
  use: string;
}

export interface RefreshTokenRequest {
  /**
   * Refresh Token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshToken: string;
}

export type CreatePATRequestMetadata = { [key: string]: unknown };

export interface CreatePATRequest {
  /** Expiration date of the PAT */
  expiresAt: string;
  metadata?: CreatePATRequestMetadata;
}

export interface CreatePATResponse {
  /**
   * ID of the PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  id: string;
  /**
   * PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  personalAccessToken: string;
}

/**
 * Error code that identifies the application error
 */
export type ErrorResponseError = typeof ErrorResponseError[keyof typeof ErrorResponseError];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseError = {
  'default-role-must-be-in-allowed-roles': 'default-role-must-be-in-allowed-roles',
  'disabled-endpoint': 'disabled-endpoint',
  'disabled-user': 'disabled-user',
  'email-already-in-use': 'email-already-in-use',
  'email-already-verified': 'email-already-verified',
  'forbidden-anonymous': 'forbidden-anonymous',
  'internal-server-error': 'internal-server-error',
  'invalid-email-password': 'invalid-email-password',
  'invalid-request': 'invalid-request',
  'locale-not-allowed': 'locale-not-allowed',
  'password-too-short': 'password-too-short',
  'password-in-hibp-database': 'password-in-hibp-database',
  'redirectTo-not-allowed': 'redirectTo-not-allowed',
  'role-not-allowed': 'role-not-allowed',
  'signup-disabled': 'signup-disabled',
  'unverified-user': 'unverified-user',
  'user-not-anonymous': 'user-not-anonymous',
  'invalid-pat': 'invalid-pat',
  'invalid-refresh-token': 'invalid-refresh-token',
  'invalid-ticket': 'invalid-ticket',
  'disabled-mfa-totp': 'disabled-mfa-totp',
  'no-totp-secret': 'no-totp-secret',
  'invalid-totp': 'invalid-totp',
  'mfa-type-not-found': 'mfa-type-not-found',
  'totp-already-active': 'totp-already-active',
} as const;

export interface ErrorResponse {
  /** HTTP status error code */
  status: number;
  /** Human friendly error message */
  message: string;
  /** Error code that identifies the application error */
  error: ErrorResponseError;
}

export interface SignInEmailPasswordResponse {
  session?: Session;
  mfa?: MFAChallengePayload;
}

export interface MFAChallengePayload {
  ticket: string;
}

export interface SessionPayload {
  session?: Session;
}

export interface Session {
  accessToken: string;
  accessTokenExpiresIn: number;
  /**
   * Refresh token id
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshTokenId: string;
  /**
   * Refresh token during authentication or when refreshing the JWT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshToken: string;
  user?: User;
}

export interface SignInPATRequest {
  /**
   * PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  personalAccessToken: string;
}

export type UserMetadata = { [key: string]: unknown };

export interface User {
  avatarUrl: string;
  createdAt: string;
  defaultRole: string;
  displayName: string;
  /** A valid email */
  email?: string;
  emailVerified: boolean;
  /**
   * Id of the user
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  id: string;
  isAnonymous: boolean;
  /**
   * A two-characters locale
   * @minLength 2
   * @maxLength 2
   */
  locale: string;
  metadata: UserMetadata;
  phoneNumber?: string;
  phoneNumberVerified: boolean;
  roles: string[];
}

/**
 * Which sign-in method to use
 */
export type UserDeanonymizeRequestSignInMethod = typeof UserDeanonymizeRequestSignInMethod[keyof typeof UserDeanonymizeRequestSignInMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserDeanonymizeRequestSignInMethod = {
  'email-password': 'email-password',
  passwordless: 'passwordless',
} as const;

export interface UserDeanonymizeRequest {
  /** Which sign-in method to use */
  signInMethod: UserDeanonymizeRequestSignInMethod;
  /** A valid email */
  email: string;
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  password?: string;
  /**
   * Deprecated, will be ignored
   * @deprecated
   */
  connection?: string;
  options?: SignUpOptions;
}

export interface UserEmailChangeRequest {
  /** A valid email */
  newEmail: string;
  options?: OptionsRedirectTo;
}

export interface UserEmailSendVerificationEmailRequest {
  /** A valid email */
  email: string;
  options?: OptionsRedirectTo;
}

export interface UserPasswordResetRequest {
  /** A valid email */
  email: string;
  options?: OptionsRedirectTo;
}

export interface UserPasswordRequest {
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  newPassword: string;
  /**
   * Ticket to reset the password, required if the user is not authenticated
   * @pattern ^passwordReset\:.*$
   */
  ticket?: string;
}

export type OKResponse = typeof OKResponse[keyof typeof OKResponse];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OKResponse = {
  OK: 'OK',
} as const;

export interface OptionsRedirectTo {
  redirectTo?: string;
}

export type SigninAnonymousRequestMetadata = { [key: string]: unknown };

export interface SigninAnonymousRequest {
  displayName?: string;
  /**
   * A two-characters locale
   * @minLength 2
   * @maxLength 2
   */
  locale?: string;
  metadata?: SigninAnonymousRequestMetadata;
}

export interface SignInEmailPasswordRequest {
  /** A valid email */
  email: string;
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  password: string;
}

export interface SignInPasswordlessEmailRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInOTPEmailRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInOTPEmailVerifyRequest {
  /** One time password */
  otp: string;
  /** A valid email */
  email: string;
}

export interface SignInOTPEmailVerifyResponse {
  session?: Session;
}

export interface SignUpEmailPasswordRequest {
  /** A valid email */
  email: string;
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  password: string;
  options?: SignUpOptions;
}

export type SignUpOptionsMetadata = { [key: string]: unknown };

export interface SignUpOptions {
  allowedRoles?: string[];
  defaultRole?: string;
  /**
   * @maxLength 32
   * @pattern ^[\p{L}\p{N}\p{S} ,.'-]+$
   */
  displayName?: string;
  /**
   * A two-characters locale
   * @minLength 2
   * @maxLength 2
   */
  locale?: string;
  metadata?: SignUpOptionsMetadata;
  redirectTo?: string;
}

export interface SignInWebauthnRequest {
  /** A valid email */
  email?: string;
}

export interface SignUpWebauthnRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInWebauthnResponse { [key: string]: unknown }

export interface SignUpWebauthnResponse { [key: string]: unknown }

export type SignInWebauthnVerifyRequestCredential = { [key: string]: unknown };

export interface SignInWebauthnVerifyRequest {
  /**
   * A valid email. Deprecated, no longer used
   * @deprecated
   */
  email?: string;
  credential: SignInWebauthnVerifyRequestCredential;
  [key: string]: unknown;
 }

export type SignUpWebauthnVerifyRequestCredential = { [key: string]: unknown };

export type SignUpWebauthnVerifyRequestOptionsAllOf = {
  nickname?: string;
};

export type SignUpWebauthnVerifyRequestOptions = SignUpOptions & SignUpWebauthnVerifyRequestOptionsAllOf;

export interface SignUpWebauthnVerifyRequest {
  credential?: SignUpWebauthnVerifyRequestCredential;
  options?: SignUpWebauthnVerifyRequestOptions;
  [key: string]: unknown;
 }

export interface SignInIdTokenRequest {
  provider: Provider;
  /** Apple ID token */
  idToken: string;
  /** Nonce used during sign in process */
  nonce?: string;
  options?: SignUpOptions;
}

export interface SignInMfaTotpRequest {
  /**
   * Ticket
   * @pattern ^mfaTotp:.*$
   */
  ticket: string;
  /** One time password */
  otp: string;
}

export type Provider = typeof Provider[keyof typeof Provider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Provider = {
  apple: 'apple',
  google: 'google',
} as const;

export interface LinkIdTokenRequest {
  provider: Provider;
  /** Apple ID token */
  idToken: string;
  /** Nonce used during sign in process */
  nonce?: string;
}

/**
 * Type of MFA to activate. If not set or set to empty string, disable MFA
 */
export type UserMfaRequestActiveMfaType = typeof UserMfaRequestActiveMfaType[keyof typeof UserMfaRequestActiveMfaType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserMfaRequestActiveMfaType = {
  totp: 'totp',
  '': '',
} as const;

export interface UserMfaRequest {
  /** MFA activation code */
  code: string;
  /** Type of MFA to activate. If not set or set to empty string, disable MFA */
  activeMfaType?: UserMfaRequestActiveMfaType;
}

export interface TotpGenerateResponse {
  /** URL to QR code image for TOTP setup */
  imageUrl: string;
  /** TOTP secret for manual setup */
  totpSecret: string;
}

/**
 * Ticket
 */
export type TicketQueryParameter = string;

/**
 * Type of the ticket
 */
export type TicketTypeQueryParameter = typeof TicketTypeQueryParameter[keyof typeof TicketTypeQueryParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TicketTypeQueryParameter = {
  emailVerify: 'emailVerify',
  emailConfirmChange: 'emailConfirmChange',
  signinPasswordless: 'signinPasswordless',
  passwordReset: 'passwordReset',
} as const;

/**
 * Target URL for the redirect
 */
export type RedirectToQueryParameter = string;

export type GetVerifyParams = {
/**
 * Ticket
 */
ticket: TicketQueryParameter;
/**
 * Type of the ticket. Deprecated, no longer used
 * @deprecated
 */
type?: TicketTypeQueryParameter;
/**
 * Target URL for the redirect
 */
redirectTo: RedirectToQueryParameter;
};

export type GetVersion200 = {
  version: string;
};

export const createApiClient = (config?: CreateAxiosDefaults) => {
  const axios = Axios.create(config);
/**
 * @summary Health check
 */
const headHealthz = <TData = AxiosResponse<void>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.head(
      `/healthz`,options
    );
  }

/**
 * @summary Health check
 */
const getHealthz = <TData = AxiosResponse<OKResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/healthz`,options
    );
  }

/**
 * @summary Get public keys for JWT verification in JWK Set format
 */
const getWellKnownJwksJson = <TData = AxiosResponse<JWKSet>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/.well-known/jwks.json`,options
    );
  }

/**
 * @summary Create a Personal Access Token (PAT)
 */
const postPat = <TData = AxiosResponse<CreatePATResponse>>(
    createPATRequest: CreatePATRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/pat`,
      createPATRequest,options
    );
  }

/**
 * @summary Refresh the JWT access token
 */
const postToken = <TData = AxiosResponse<Session>>(
    refreshTokenRequest: RefreshTokenRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/token`,
      refreshTokenRequest,options
    );
  }

/**
 * @summary Sign in anonymously
 */
const postSigninAnonymous = <TData = AxiosResponse<SessionPayload>>(
    signinAnonymousRequest?: SigninAnonymousRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/anonymous`,
      signinAnonymousRequest,options
    );
  }

/**
 * @summary Sign in with email and password
 */
const signinEmailPassword = <TData = AxiosResponse<SignInEmailPasswordResponse>>(
    signInEmailPasswordRequest: SignInEmailPasswordRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/email-password`,
      signInEmailPasswordRequest,options
    );
  }

/**
 * @summary Verify TOTP and return a session if validation is successful
 */
const postSigninMfaTotp = <TData = AxiosResponse<SessionPayload>>(
    signInMfaTotpRequest: SignInMfaTotpRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/mfa/totp`,
      signInMfaTotpRequest,options
    );
  }

/**
 * @summary Sign in with magic link sent to user's email. If the user doesn't exist, it will be created. The options object is optional and can be used to configure the user's when signing up a new user. It is ignored if the user already exists.
 */
const postSigninPasswordlessEmail = <TData = AxiosResponse<OKResponse>>(
    signInPasswordlessEmailRequest: SignInPasswordlessEmailRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/passwordless/email`,
      signInPasswordlessEmailRequest,options
    );
  }

/**
 * @summary Sign in with a one time password sent to user's email. If the user doesn't exist, it will be created. The options object is optional and can be used to configure the user's when signing up a new user. It is ignored if the user already exists.
 */
const postSigninOtpEmail = <TData = AxiosResponse<OKResponse>>(
    signInOTPEmailRequest: SignInOTPEmailRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/otp/email`,
      signInOTPEmailRequest,options
    );
  }

/**
 * @summary Verify OTP and return a session if validation is successful
 */
const postSigninOtpEmailVerify = <TData = AxiosResponse<SignInOTPEmailVerifyResponse>>(
    signInOTPEmailVerifyRequest: SignInOTPEmailVerifyRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/otp/email/verify`,
      signInOTPEmailVerifyRequest,options
    );
  }

/**
 * @summary Sign in with Personal Access Token (PAT)
 */
const postSigninPat = <TData = AxiosResponse<SessionPayload>>(
    signInPATRequest: SignInPATRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/pat`,
      signInPATRequest,options
    );
  }

/**
 * @summary Sign in with in an id token
 */
const postSigninIdtoken = <TData = AxiosResponse<SessionPayload>>(
    signInIdTokenRequest: SignInIdTokenRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/idtoken`,
      signInIdTokenRequest,options
    );
  }

/**
 * @summary Signup with email and password
 */
const signupEmailPassword = <TData = AxiosResponse<SessionPayload>>(
    signUpEmailPasswordRequest: SignUpEmailPasswordRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signup/email-password`,
      signUpEmailPasswordRequest,options
    );
  }

/**
 * @summary Signin with webauthn
 */
const postSigninWebauthn = <TData = AxiosResponse<SignInWebauthnResponse>>(
    signInWebauthnRequest: SignInWebauthnRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/webauthn`,
      signInWebauthnRequest,options
    );
  }

/**
 * @summary Verify webauthn signin
 */
const postSigninWebauthnVerify = <TData = AxiosResponse<SessionPayload>>(
    signInWebauthnVerifyRequest: SignInWebauthnVerifyRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/webauthn/verify`,
      signInWebauthnVerifyRequest,options
    );
  }

/**
 * @summary Signup with webauthn
 */
const postSignupWebauthn = <TData = AxiosResponse<SignUpWebauthnResponse>>(
    signUpWebauthnRequest: SignUpWebauthnRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signup/webauthn`,
      signUpWebauthnRequest,options
    );
  }

/**
 * @summary Verify webauthn signup
 */
const postSignupWebauthnVerify = <TData = AxiosResponse<SessionPayload>>(
    signUpWebauthnVerifyRequest: SignUpWebauthnVerifyRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signup/webauthn/verify`,
      signUpWebauthnVerifyRequest,options
    );
  }

/**
 * @summary Link a user account with the provider's account using an id token
 */
const postLinkIdtoken = <TData = AxiosResponse<OKResponse>>(
    linkIdTokenRequest: LinkIdTokenRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/link/idtoken`,
      linkIdTokenRequest,options
    );
  }

/**
 * @summary Deanonymize an anonymous user in adding missing email or email+password, depending on the chosen authentication method. Will send a confirmation email if the server is configured to do so
 */
const postUserDeanonymize = <TData = AxiosResponse<OKResponse>>(
    userDeanonymizeRequest: UserDeanonymizeRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/user/deanonymize`,
      userDeanonymizeRequest,options
    );
  }

/**
 * @summary Change user email
 */
const postUserEmailChange = <TData = AxiosResponse<OKResponse>>(
    userEmailChangeRequest: UserEmailChangeRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/user/email/change`,
      userEmailChangeRequest,options
    );
  }

/**
 * @summary Send email verification email
 */
const postUserEmailSendVerificationEmail = <TData = AxiosResponse<OKResponse>>(
    userEmailSendVerificationEmailRequest: UserEmailSendVerificationEmailRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/user/email/send-verification-email`,
      userEmailSendVerificationEmailRequest,options
    );
  }

/**
 * @summary Change user password. The user must be authenticated or provide a ticket
 */
const postUserPassword = <TData = AxiosResponse<OKResponse>>(
    userPasswordRequest: UserPasswordRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/user/password`,
      userPasswordRequest,options
    );
  }

/**
 * @summary Request a password reset. An email with a verification link will be sent to the user's address
 */
const postUserPasswordReset = <TData = AxiosResponse<OKResponse>>(
    userPasswordResetRequest: UserPasswordResetRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/user/password/reset`,
      userPasswordResetRequest,options
    );
  }

/**
 * @summary Verify tickets created by email verification, email passwordless authentication (magic link), or password reset
 */
const getVerify = <TData = AxiosResponse<unknown>>(
    params: GetVerifyParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/verify`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get version
 */
const getVersion = <TData = AxiosResponse<GetVersion200>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/version`,options
    );
  }

/**
 * @summary Activate/deactivate Multi-factor authentication
 */
const postUserMfa = <TData = AxiosResponse<OKResponse>>(
    userMfaRequest: UserMfaRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/user/mfa`,
      userMfaRequest,options
    );
  }

/**
 * @summary Generate TOTP secret for MFA setup
 */
const getMfaTotpGenerate = <TData = AxiosResponse<TotpGenerateResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/mfa/totp/generate`,options
    );
  }

return {headHealthz,getHealthz,getWellKnownJwksJson,postPat,postToken,postSigninAnonymous,signinEmailPassword,postSigninMfaTotp,postSigninPasswordlessEmail,postSigninOtpEmail,postSigninOtpEmailVerify,postSigninPat,postSigninIdtoken,signupEmailPassword,postSigninWebauthn,postSigninWebauthnVerify,postSignupWebauthn,postSignupWebauthnVerify,postLinkIdtoken,postUserDeanonymize,postUserEmailChange,postUserEmailSendVerificationEmail,postUserPassword,postUserPasswordReset,getVerify,getVersion,postUserMfa,getMfaTotpGenerate, axios}};
export type HeadHealthzResult = AxiosResponse<void>
export type GetHealthzResult = AxiosResponse<OKResponse>
export type GetWellKnownJwksJsonResult = AxiosResponse<JWKSet>
export type PostPatResult = AxiosResponse<CreatePATResponse>
export type PostTokenResult = AxiosResponse<Session>
export type PostSigninAnonymousResult = AxiosResponse<SessionPayload>
export type SigninEmailPasswordResult = AxiosResponse<SignInEmailPasswordResponse>
export type PostSigninMfaTotpResult = AxiosResponse<SessionPayload>
export type PostSigninPasswordlessEmailResult = AxiosResponse<OKResponse>
export type PostSigninOtpEmailResult = AxiosResponse<OKResponse>
export type PostSigninOtpEmailVerifyResult = AxiosResponse<SignInOTPEmailVerifyResponse>
export type PostSigninPatResult = AxiosResponse<SessionPayload>
export type PostSigninIdtokenResult = AxiosResponse<SessionPayload>
export type SignupEmailPasswordResult = AxiosResponse<SessionPayload>
export type PostSigninWebauthnResult = AxiosResponse<SignInWebauthnResponse>
export type PostSigninWebauthnVerifyResult = AxiosResponse<SessionPayload>
export type PostSignupWebauthnResult = AxiosResponse<SignUpWebauthnResponse>
export type PostSignupWebauthnVerifyResult = AxiosResponse<SessionPayload>
export type PostLinkIdtokenResult = AxiosResponse<OKResponse>
export type PostUserDeanonymizeResult = AxiosResponse<OKResponse>
export type PostUserEmailChangeResult = AxiosResponse<OKResponse>
export type PostUserEmailSendVerificationEmailResult = AxiosResponse<OKResponse>
export type PostUserPasswordResult = AxiosResponse<OKResponse>
export type PostUserPasswordResetResult = AxiosResponse<OKResponse>
export type GetVerifyResult = AxiosResponse<unknown>
export type GetVersionResult = AxiosResponse<GetVersion200>
export type PostUserMfaResult = AxiosResponse<OKResponse>
export type GetMfaTotpGenerateResult = AxiosResponse<TotpGenerateResponse>
