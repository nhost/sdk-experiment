/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * Nhost Authentication API
 * Comprehensive authentication service for managing user identities, sessions, and authentication methods
 * OpenAPI spec version: 1.0.0
 */
import Axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse,
  CreateAxiosDefaults
} from 'axios';

/**
 * JSON Web Key Set for verifying JWT signatures
 */
export interface JWKSet {
  /** Array of public keys */
  keys: Jwk[];
}

/**
 * JSON Web Key for JWT verification
 */
export interface Jwk {
  /** Algorithm used with this key */
  alg: string;
  /** RSA public exponent */
  e: string;
  /** Key ID */
  kid: string;
  /** Key type */
  kty: string;
  /** RSA modulus */
  n: string;
  /** Key usage */
  use: string;
}

/**
 * Request to refresh an access token
 */
export interface RefreshTokenRequest {
  /**
   * Refresh token used to generate a new access token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshToken: string;
}

export interface SignOutSchema {
  /** Refresh token for the current session */
  refreshToken: string;
  /** Sign out from all connected devices */
  all?: boolean;
}

export type CreatePATRequestMetadata = { [key: string]: unknown };

export interface CreatePATRequest {
  /** Expiration date of the PAT */
  expiresAt: string;
  metadata?: CreatePATRequestMetadata;
}

export interface CreatePATResponse {
  /**
   * ID of the PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  id: string;
  /**
   * PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  personalAccessToken: string;
}

/**
 * Error code identifying the specific application error
 */
export type ErrorResponseError = typeof ErrorResponseError[keyof typeof ErrorResponseError];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseError = {
  'default-role-must-be-in-allowed-roles': 'default-role-must-be-in-allowed-roles',
  'disabled-endpoint': 'disabled-endpoint',
  'disabled-user': 'disabled-user',
  'email-already-in-use': 'email-already-in-use',
  'email-already-verified': 'email-already-verified',
  'forbidden-anonymous': 'forbidden-anonymous',
  'internal-server-error': 'internal-server-error',
  'invalid-email-password': 'invalid-email-password',
  'invalid-request': 'invalid-request',
  'locale-not-allowed': 'locale-not-allowed',
  'password-too-short': 'password-too-short',
  'password-in-hibp-database': 'password-in-hibp-database',
  'redirectTo-not-allowed': 'redirectTo-not-allowed',
  'role-not-allowed': 'role-not-allowed',
  'signup-disabled': 'signup-disabled',
  'unverified-user': 'unverified-user',
  'user-not-anonymous': 'user-not-anonymous',
  'invalid-pat': 'invalid-pat',
  'invalid-refresh-token': 'invalid-refresh-token',
  'invalid-ticket': 'invalid-ticket',
  'disabled-mfa-totp': 'disabled-mfa-totp',
  'no-totp-secret': 'no-totp-secret',
  'invalid-totp': 'invalid-totp',
  'mfa-type-not-found': 'mfa-type-not-found',
  'totp-already-active': 'totp-already-active',
} as const;

/**
 * Standardized error response
 */
export interface ErrorResponse {
  /** HTTP status error code */
  status: number;
  /** Human-friendly error message */
  message: string;
  /** Error code identifying the specific application error */
  error: ErrorResponseError;
}

/**
 * Response for email-password authentication that may include a session or MFA challenge
 */
export interface SignInEmailPasswordResponse {
  /** User session if authentication was successful. Null if MFA challenge is required. */
  session?: Session;
  /** MFA challenge if two-factor authentication is required */
  mfa?: MFAChallengePayload;
}

/**
 * Challenge payload for multi-factor authentication
 */
export interface MFAChallengePayload {
  /** Ticket to use when completing the MFA challenge */
  ticket: string;
}

/**
 * Container for session information
 */
export interface SessionPayload {
  /** User session data. Null if authentication requires additional steps. */
  session?: Session;
}

/**
 * User authentication session containing tokens and user information
 */
export interface Session {
  /** JWT token for authenticating API requests */
  accessToken: string;
  /** Expiration time of the access token in seconds */
  accessTokenExpiresIn: number;
  /**
   * Identifier for the refresh token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshTokenId: string;
  /**
   * Token used to refresh the access token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshToken: string;
  /** Information about the authenticated user */
  user?: User;
}

export interface SignInPATRequest {
  /**
   * PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  personalAccessToken: string;
}

/**
 * Custom metadata associated with the user
 */
export type UserMetadata = { [key: string]: unknown };

/**
 * User profile and account information
 */
export interface User {
  /** URL to the user's profile picture */
  avatarUrl: string;
  /** Timestamp when the user account was created */
  createdAt: string;
  /** Default authorization role for the user */
  defaultRole: string;
  /** User's display name */
  displayName: string;
  /** User's email address */
  email?: string;
  /** Whether the user's email has been verified */
  emailVerified: boolean;
  /**
   * Unique identifier for the user
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  id: string;
  /** Whether this is an anonymous user account */
  isAnonymous: boolean;
  /**
   * User's preferred locale (language code)
   * @minLength 2
   * @maxLength 2
   */
  locale: string;
  /** Custom metadata associated with the user */
  metadata: UserMetadata;
  /** User's phone number */
  phoneNumber?: string;
  /** Whether the user's phone number has been verified */
  phoneNumberVerified: boolean;
  /** List of roles assigned to the user */
  roles: string[];
}

/**
 * Which sign-in method to use
 */
export type UserDeanonymizeRequestSignInMethod = typeof UserDeanonymizeRequestSignInMethod[keyof typeof UserDeanonymizeRequestSignInMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserDeanonymizeRequestSignInMethod = {
  'email-password': 'email-password',
  passwordless: 'passwordless',
} as const;

export interface UserDeanonymizeRequest {
  /** Which sign-in method to use */
  signInMethod: UserDeanonymizeRequestSignInMethod;
  /** A valid email */
  email: string;
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  password?: string;
  /**
   * Deprecated, will be ignored
   * @deprecated
   */
  connection?: string;
  options?: SignUpOptions;
}

export interface UserEmailChangeRequest {
  /** A valid email */
  newEmail: string;
  options?: OptionsRedirectTo;
}

export interface UserEmailSendVerificationEmailRequest {
  /** A valid email */
  email: string;
  options?: OptionsRedirectTo;
}

export interface UserPasswordResetRequest {
  /** A valid email */
  email: string;
  options?: OptionsRedirectTo;
}

export interface UserPasswordRequest {
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  newPassword: string;
  /**
   * Ticket to reset the password, required if the user is not authenticated
   * @pattern ^passwordReset\:.*$
   */
  ticket?: string;
}

export type OKResponse = typeof OKResponse[keyof typeof OKResponse];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OKResponse = {
  OK: 'OK',
} as const;

export interface OptionsRedirectTo {
  redirectTo?: string;
}

export type SigninAnonymousRequestMetadata = { [key: string]: unknown };

export interface SigninAnonymousRequest {
  displayName?: string;
  /**
   * A two-characters locale
   * @minLength 2
   * @maxLength 2
   */
  locale?: string;
  metadata?: SigninAnonymousRequestMetadata;
}

/**
 * Request to authenticate using email and password
 */
export interface SignInEmailPasswordRequest {
  /** User's email address */
  email: string;
  /**
   * User's password
   * @minLength 3
   * @maxLength 50
   */
  password: string;
}

export interface SignInPasswordlessEmailRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInOTPEmailRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInOTPEmailVerifyRequest {
  /** One time password */
  otp: string;
  /** A valid email */
  email: string;
}

export interface SignInOTPEmailVerifyResponse {
  session?: Session;
}

/**
 * Request to register a new user with email and password
 */
export interface SignUpEmailPasswordRequest {
  /** Email address for the new user account */
  email: string;
  /**
   * Password for the new user account
   * @minLength 3
   * @maxLength 50
   */
  password: string;
  /** Optional configuration for the new user account */
  options?: SignUpOptions;
}

export type SignUpOptionsMetadata = { [key: string]: unknown };

export interface SignUpOptions {
  allowedRoles?: string[];
  defaultRole?: string;
  /**
   * @maxLength 32
   * @pattern ^[\p{L}\p{N}\p{S} ,.'-]+$
   */
  displayName?: string;
  /**
   * A two-characters locale
   * @minLength 2
   * @maxLength 2
   */
  locale?: string;
  metadata?: SignUpOptionsMetadata;
  redirectTo?: string;
}

export interface SignInWebauthnRequest {
  /** A valid email */
  email?: string;
}

export interface SignUpWebauthnRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInWebauthnResponse { [key: string]: unknown }

export interface SignUpWebauthnResponse { [key: string]: unknown }

export type SignInWebauthnVerifyRequestCredential = { [key: string]: unknown };

export interface SignInWebauthnVerifyRequest {
  /**
   * A valid email. Deprecated, no longer used
   * @deprecated
   */
  email?: string;
  credential: SignInWebauthnVerifyRequestCredential;
  [key: string]: unknown;
 }

export type SignUpWebauthnVerifyRequestCredential = { [key: string]: unknown };

export type SignUpWebauthnVerifyRequestOptionsAllOf = {
  nickname?: string;
};

export type SignUpWebauthnVerifyRequestOptions = SignUpOptions & SignUpWebauthnVerifyRequestOptionsAllOf;

export interface SignUpWebauthnVerifyRequest {
  credential?: SignUpWebauthnVerifyRequestCredential;
  options?: SignUpWebauthnVerifyRequestOptions;
  [key: string]: unknown;
 }

export interface SignInIdTokenRequest {
  provider: Provider;
  /** Apple ID token */
  idToken: string;
  /** Nonce used during sign in process */
  nonce?: string;
  options?: SignUpOptions;
}

export interface SignInMfaTotpRequest {
  /**
   * Ticket
   * @pattern ^mfaTotp:.*$
   */
  ticket: string;
  /** One time password */
  otp: string;
}

export type Provider = typeof Provider[keyof typeof Provider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Provider = {
  apple: 'apple',
  google: 'google',
} as const;

export interface LinkIdTokenRequest {
  provider: Provider;
  /** Apple ID token */
  idToken: string;
  /** Nonce used during sign in process */
  nonce?: string;
}

/**
 * Type of MFA to activate. Use empty string to disable MFA.
 */
export type UserMfaRequestActiveMfaType = typeof UserMfaRequestActiveMfaType[keyof typeof UserMfaRequestActiveMfaType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserMfaRequestActiveMfaType = {
  totp: 'totp',
  '': '',
} as const;

/**
 * Request to activate or deactivate multi-factor authentication
 */
export interface UserMfaRequest {
  /** Verification code from the authenticator app when activating MFA */
  code: string;
  /** Type of MFA to activate. Use empty string to disable MFA. */
  activeMfaType?: UserMfaRequestActiveMfaType;
}

/**
 * Response containing TOTP setup information for MFA
 */
export interface TotpGenerateResponse {
  /** URL to QR code image for scanning with an authenticator app */
  imageUrl: string;
  /** TOTP secret key for manual setup with an authenticator app */
  totpSecret: string;
}

/**
 * Ticket
 */
export type TicketQueryParameter = string;

/**
 * Type of the ticket
 */
export type TicketTypeQueryParameter = typeof TicketTypeQueryParameter[keyof typeof TicketTypeQueryParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TicketTypeQueryParameter = {
  emailVerify: 'emailVerify',
  emailConfirmChange: 'emailConfirmChange',
  signinPasswordless: 'signinPasswordless',
  passwordReset: 'passwordReset',
} as const;

/**
 * Target URL for the redirect
 */
export type RedirectToQueryParameter = string;

export type GetVersion200 = {
  /** The version of the authentication service */
  version: string;
};

export const createApiClient = (config?: CreateAxiosDefaults) => {
  const axios = Axios.create(config);
/**
 * Verify if the authentication service is operational using HEAD method
 * @summary Health check (HEAD)
 */
const healthCheckHead = <TData = AxiosResponse<void>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.head(
      `/healthz`,options
    );
  }

/**
 * Verify if the authentication service is operational using GET method
 * @summary Health check (GET)
 */
const healthCheckGet = <TData = AxiosResponse<OKResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/healthz`,options
    );
  }

/**
 * Retrieve version information about the authentication service
 * @summary Get service version
 */
const getVersion = <TData = AxiosResponse<GetVersion200>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/version`,options
    );
  }

/**
 * Generate a new JWT access token using a valid refresh token. The refresh token used will be revoked and a new one will be issued.
 * @summary Refresh access token
 */
const refreshToken = <TData = AxiosResponse<Session>>(
    refreshTokenRequest: RefreshTokenRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/token`,
      refreshTokenRequest,options
    );
  }

/**
 * @summary Sign out
 */
const signOut = <TData = AxiosResponse<OKResponse>>(
    signOutSchema: SignOutSchema, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signout`,
      signOutSchema,options
    );
  }

/**
 * Authenticate a user with their email and password. Returns a session object or MFA challenge if two-factor authentication is enabled.
 * @summary Sign in with email and password
 */
const signinEmailPassword = <TData = AxiosResponse<SignInEmailPasswordResponse>>(
    signInEmailPasswordRequest: SignInEmailPasswordRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/email-password`,
      signInEmailPasswordRequest,options
    );
  }

/**
 * Complete the multi-factor authentication by verifying a Time-based One-Time Password (TOTP). Returns a session if validation is successful.
 * @summary Verify TOTP for MFA
 */
const signinVerifyMfaTotp = <TData = AxiosResponse<SessionPayload>>(
    signInMfaTotpRequest: SignInMfaTotpRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/mfa/totp`,
      signInMfaTotpRequest,options
    );
  }

/**
 * Initiate passwordless authentication by sending a magic link to the user's email. If the user doesn't exist, a new account will be created with the provided options.
 * @summary Sign in with magic link email
 */
const signinPasswordlessEmail = <TData = AxiosResponse<OKResponse>>(
    signInPasswordlessEmailRequest: SignInPasswordlessEmailRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signin/passwordless/email`,
      signInPasswordlessEmailRequest,options
    );
  }

/**
 * Register a new user account with email and password. Returns a session if email verification is not required, otherwise returns null session.
 * @summary Sign up with email and password
 */
const signupEmailPassword = <TData = AxiosResponse<SessionPayload>>(
    signUpEmailPasswordRequest: SignUpEmailPasswordRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/signup/email-password`,
      signUpEmailPasswordRequest,options
    );
  }

/**
 * Activate or deactivate multi-factor authentication for the authenticated user
 * @summary Manage multi-factor authentication
 */
const changeUserMfaVerify = <TData = AxiosResponse<OKResponse>>(
    userMfaRequest: UserMfaRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/user/mfa`,
      userMfaRequest,options
    );
  }

/**
 * Generate a Time-based One-Time Password (TOTP) secret for setting up multi-factor authentication
 * @summary Generate TOTP secret
 */
const changeUserMfa = <TData = AxiosResponse<TotpGenerateResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/mfa/totp/generate`,options
    );
  }

return {healthCheckHead,healthCheckGet,getVersion,refreshToken,signOut,signinEmailPassword,signinVerifyMfaTotp,signinPasswordlessEmail,signupEmailPassword,changeUserMfaVerify,changeUserMfa, axios}};
export type HealthCheckHeadResult = AxiosResponse<void>
export type HealthCheckGetResult = AxiosResponse<OKResponse>
export type GetVersionResult = AxiosResponse<GetVersion200>
export type RefreshTokenResult = AxiosResponse<Session>
export type SignOutResult = AxiosResponse<OKResponse>
export type SigninEmailPasswordResult = AxiosResponse<SignInEmailPasswordResponse>
export type SigninVerifyMfaTotpResult = AxiosResponse<SessionPayload>
export type SigninPasswordlessEmailResult = AxiosResponse<OKResponse>
export type SignupEmailPasswordResult = AxiosResponse<SessionPayload>
export type ChangeUserMfaVerifyResult = AxiosResponse<OKResponse>
export type ChangeUserMfaResult = AxiosResponse<TotpGenerateResponse>
