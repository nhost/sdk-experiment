/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Nhost Authentication API
 * Comprehensive authentication service for managing user identities, sessions, and authentication methods
 * OpenAPI spec version: 1.0.0
 */
import { createEnhancedFetch } from "../fetch";
import type { ChainFunction } from "../fetch";

import type { Client } from "./interface";

/**
 * JSON Web Key Set for verifying JWT signatures
 */
export interface JWKSet {
  /** Array of public keys */
  keys: Jwk[];
}

/**
 * JSON Web Key for JWT verification
 */
export interface Jwk {
  /** Algorithm used with this key */
  alg: string;
  /** RSA public exponent */
  e: string;
  /** Key ID */
  kid: string;
  /** Key type */
  kty: string;
  /** RSA modulus */
  n: string;
  /** Key usage */
  use: string;
}

/**
 * Request to refresh an access token
 */
export interface RefreshTokenRequest {
  /**
   * Refresh token used to generate a new access token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshToken: string;
}

export interface SignOutSchema {
  /** Refresh token for the current session */
  refreshToken: string;
  /** Sign out from all connected devices */
  all?: boolean;
}

export type CreatePATRequestMetadata = { [key: string]: unknown };

export interface CreatePATRequest {
  /** Expiration date of the PAT */
  expiresAt: string;
  metadata?: CreatePATRequestMetadata;
}

export interface CreatePATResponse {
  /**
   * ID of the PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  id: string;
  /**
   * PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  personalAccessToken: string;
}

/**
 * Error code identifying the specific application error
 */
export type ErrorResponseError =
  | "default-role-must-be-in-allowed-roles"
  | "disabled-endpoint"
  | "disabled-user"
  | "email-already-in-use"
  | "email-already-verified"
  | "forbidden-anonymous"
  | "internal-server-error"
  | "invalid-email-password"
  | "invalid-request"
  | "locale-not-allowed"
  | "password-too-short"
  | "password-in-hibp-database"
  | "redirectTo-not-allowed"
  | "role-not-allowed"
  | "signup-disabled"
  | "unverified-user"
  | "user-not-anonymous"
  | "invalid-pat"
  | "invalid-refresh-token"
  | "invalid-ticket"
  | "disabled-mfa-totp"
  | "no-totp-secret"
  | "invalid-totp"
  | "mfa-type-not-found"
  | "totp-already-active";
/**
 * Standardized error response
 */
export interface ErrorResponse {
  /** HTTP status error code */
  status: number;
  /** Human-friendly error message */
  message: string;
  /** Error code identifying the specific application error */
  error: ErrorResponseError;
}

/**
 * Response for email-password authentication that may include a session or MFA challenge
 */
export interface SignInEmailPasswordResponse {
  /** User session if authentication was successful. Null if MFA challenge is required. */
  session?: Session;
  /** MFA challenge if two-factor authentication is required */
  mfa?: MFAChallengePayload;
}

/**
 * Challenge payload for multi-factor authentication
 */
export interface MFAChallengePayload {
  /** Ticket to use when completing the MFA challenge */
  ticket: string;
}

/**
 * Container for session information
 */
export interface SessionPayload {
  /** User session data. Null if authentication requires additional steps. */
  session?: Session;
}

/**
 * User authentication session containing tokens and user information
 */
export interface Session {
  /** JWT token for authenticating API requests */
  accessToken: string;
  /** Expiration time of the access token in seconds */
  accessTokenExpiresIn: number;
  /**
   * Identifier for the refresh token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshTokenId: string;
  /**
   * Token used to refresh the access token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshToken: string;
  /** Information about the authenticated user */
  user?: User;
}

export interface SignInPATRequest {
  /**
   * PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  personalAccessToken: string;
}

/**
 * Custom metadata associated with the user
 */
export type UserMetadata = { [key: string]: unknown };

/**
 * User profile and account information
 */
export interface User {
  /** URL to the user's profile picture */
  avatarUrl: string;
  /** Timestamp when the user account was created */
  createdAt: string;
  /** Default authorization role for the user */
  defaultRole: string;
  /** User's display name */
  displayName: string;
  /** User's email address */
  email?: string;
  /** Whether the user's email has been verified */
  emailVerified: boolean;
  /**
   * Unique identifier for the user
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  id: string;
  /** Whether this is an anonymous user account */
  isAnonymous: boolean;
  /**
   * User's preferred locale (language code)
   * @minLength 2
   * @maxLength 2
   */
  locale: string;
  /** Custom metadata associated with the user */
  metadata: UserMetadata;
  /** User's phone number */
  phoneNumber?: string;
  /** Whether the user's phone number has been verified */
  phoneNumberVerified: boolean;
  /** List of roles assigned to the user */
  roles: string[];
}

/**
 * Which sign-in method to use
 */
export type UserDeanonymizeRequestSignInMethod =
  | "email-password"
  | "passwordless";
export interface UserDeanonymizeRequest {
  /** Which sign-in method to use */
  signInMethod: UserDeanonymizeRequestSignInMethod;
  /** A valid email */
  email: string;
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  password?: string;
  /**
   * Deprecated, will be ignored
   * @deprecated
   */
  connection?: string;
  options?: SignUpOptions;
}

export interface UserEmailChangeRequest {
  /** A valid email */
  newEmail: string;
  options?: OptionsRedirectTo;
}

export interface UserEmailSendVerificationEmailRequest {
  /** A valid email */
  email: string;
  options?: OptionsRedirectTo;
}

export interface UserPasswordResetRequest {
  /** A valid email */
  email: string;
  options?: OptionsRedirectTo;
}

export interface UserPasswordRequest {
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  newPassword: string;
  /**
   * Ticket to reset the password, required if the user is not authenticated
   * @pattern ^passwordReset\:.*$
   */
  ticket?: string;
}

export type OKResponse = "OK";
export interface OptionsRedirectTo {
  redirectTo?: string;
}

export type SigninAnonymousRequestMetadata = { [key: string]: unknown };

export interface SigninAnonymousRequest {
  displayName?: string;
  /**
   * A two-characters locale
   * @minLength 2
   * @maxLength 2
   */
  locale?: string;
  metadata?: SigninAnonymousRequestMetadata;
}

/**
 * Request to authenticate using email and password
 */
export interface SignInEmailPasswordRequest {
  /** User's email address */
  email: string;
  /**
   * User's password
   * @minLength 3
   * @maxLength 50
   */
  password: string;
}

export interface SignInPasswordlessEmailRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInOTPEmailRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInOTPEmailVerifyRequest {
  /** One time password */
  otp: string;
  /** A valid email */
  email: string;
}

export interface SignInOTPEmailVerifyResponse {
  session?: Session;
}

/**
 * Request to register a new user with email and password
 */
export interface SignUpEmailPasswordRequest {
  /** Email address for the new user account */
  email: string;
  /**
   * Password for the new user account
   * @minLength 3
   * @maxLength 50
   */
  password: string;
  /** Optional configuration for the new user account */
  options?: SignUpOptions;
}

export type SignUpOptionsMetadata = { [key: string]: unknown };

export interface SignUpOptions {
  allowedRoles?: string[];
  defaultRole?: string;
  /**
   * @maxLength 32
   * @pattern ^[\p{L}\p{N}\p{S} ,.'-]+$
   */
  displayName?: string;
  /**
   * A two-characters locale
   * @minLength 2
   * @maxLength 2
   */
  locale?: string;
  metadata?: SignUpOptionsMetadata;
  redirectTo?: string;
}

export interface SignInWebauthnRequest {
  /** A valid email */
  email?: string;
}

export interface SignUpWebauthnRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInWebauthnResponse {
  [key: string]: unknown;
}

export interface SignUpWebauthnResponse {
  [key: string]: unknown;
}

export type SignInWebauthnVerifyRequestCredential = { [key: string]: unknown };

export interface SignInWebauthnVerifyRequest {
  /**
   * A valid email. Deprecated, no longer used
   * @deprecated
   */
  email?: string;
  credential: SignInWebauthnVerifyRequestCredential;
  [key: string]: unknown;
}

export type SignUpWebauthnVerifyRequestCredential = { [key: string]: unknown };

export type SignUpWebauthnVerifyRequestOptionsAllOf = {
  nickname?: string;
};

export type SignUpWebauthnVerifyRequestOptions = SignUpOptions &
  SignUpWebauthnVerifyRequestOptionsAllOf;

export interface SignUpWebauthnVerifyRequest {
  credential?: SignUpWebauthnVerifyRequestCredential;
  options?: SignUpWebauthnVerifyRequestOptions;
  [key: string]: unknown;
}

export interface SignInIdTokenRequest {
  provider: Provider;
  /** Apple ID token */
  idToken: string;
  /** Nonce used during sign in process */
  nonce?: string;
  options?: SignUpOptions;
}

export interface SignInMfaTotpRequest {
  /**
   * Ticket
   * @pattern ^mfaTotp:.*$
   */
  ticket: string;
  /** One time password */
  otp: string;
}

export type Provider = "apple" | "google";
export interface LinkIdTokenRequest {
  provider: Provider;
  /** Apple ID token */
  idToken: string;
  /** Nonce used during sign in process */
  nonce?: string;
}

/**
 * Type of MFA to activate. Use empty string to disable MFA.
 */
export type UserMfaRequestActiveMfaType = "totp" | "";
/**
 * Request to activate or deactivate multi-factor authentication
 */
export interface UserMfaRequest {
  /** Verification code from the authenticator app when activating MFA */
  code: string;
  /** Type of MFA to activate. Use empty string to disable MFA. */
  activeMfaType?: UserMfaRequestActiveMfaType;
}

/**
 * Response containing TOTP setup information for MFA
 */
export interface TotpGenerateResponse {
  /** URL to QR code image for scanning with an authenticator app */
  imageUrl: string;
  /** TOTP secret key for manual setup with an authenticator app */
  totpSecret: string;
}

/**
 * Ticket
 */
export type TicketQueryParameter = string;

/**
 * Type of the ticket
 */
export type TicketTypeQueryParameter =
  | "emailVerify"
  | "emailConfirmChange"
  | "signinPasswordless"
  | "passwordReset";
/**
 * Target URL for the redirect
 */
export type RedirectToQueryParameter = string;

export type GetVersion200 = {
  /** The version of the authentication service */
  version: string;
};

export type VerifyTicketParams = {
  /**
   * Ticket
   */
  ticket: TicketQueryParameter;
  /**
   * Type of the ticket. Deprecated, no longer used
   * @deprecated
   */
  type?: TicketTypeQueryParameter;
  /**
   * Target URL for the redirect
   */
  redirectTo: RedirectToQueryParameter;
};

export type FetchResponse<T> = {
  body: T;
  status: number;
  headers: Headers;
};

export const createAPIClient = (
  baseURL: string,
  chainFunctions: ChainFunction[] = [],
): Client => {
  let fetch = createEnhancedFetch(chainFunctions);

  const pushChainFunction = (chainFunction: ChainFunction) => {
    chainFunctions.push(chainFunction);
    fetch = createEnhancedFetch(chainFunctions);
  };

  /**
   * Verify if the authentication service is operational using HEAD method
   * @summary Health check (HEAD)
   */
  const healthCheckHead = async (
    options?: RequestInit,
  ): Promise<FetchResponse<void>> => {
    const res = await fetch(getHealthCheckHeadUrl(), {
      ...options,
      method: "HEAD",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: void = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<void>;

    return response;
  };

  const getHealthCheckHeadUrl = () => {
    return baseURL + `/healthz`;
  };

  /**
   * Verify if the authentication service is operational using GET method
   * @summary Health check (GET)
   */
  const healthCheckGet = async (
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse>> => {
    const res = await fetch(getHealthCheckGetUrl(), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse>;

    return response;
  };

  const getHealthCheckGetUrl = () => {
    return baseURL + `/healthz`;
  };

  /**
   * Retrieve version information about the authentication service
   * @summary Get service version
   */
  const getVersion = async (
    options?: RequestInit,
  ): Promise<FetchResponse<GetVersion200>> => {
    const res = await fetch(getGetVersionUrl(), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: GetVersion200 = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<GetVersion200>;

    return response;
  };

  const getGetVersionUrl = () => {
    return baseURL + `/version`;
  };

  /**
   * Generate a new JWT access token using a valid refresh token. The refresh token used will be revoked and a new one will be issued.
   * @summary Refresh access token
   */
  const refreshToken = async (
    refreshTokenRequest: RefreshTokenRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<Session | ErrorResponse>> => {
    const res = await fetch(getRefreshTokenUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(refreshTokenRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: Session | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<Session | ErrorResponse>;

    return response;
  };

  const getRefreshTokenUrl = () => {
    return baseURL + `/token`;
  };

  /**
   * @summary Sign out
   */
  const signOut = async (
    signOutSchema: SignOutSchema,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getSignOutUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signOutSchema),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getSignOutUrl = () => {
    return baseURL + `/signout`;
  };

  /**
   * Authenticate a user with their email and password. Returns a session object or MFA challenge if two-factor authentication is enabled.
   * @summary Sign in with email and password
   */
  const signInEmailPassword = async (
    signInEmailPasswordRequest: SignInEmailPasswordRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SignInEmailPasswordResponse | ErrorResponse>> => {
    const res = await fetch(getSignInEmailPasswordUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInEmailPasswordRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: SignInEmailPasswordResponse | ErrorResponse = body
      ? JSON.parse(body)
      : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<SignInEmailPasswordResponse | ErrorResponse>;

    return response;
  };

  const getSignInEmailPasswordUrl = () => {
    return baseURL + `/signin/email-password`;
  };

  /**
   * Complete the multi-factor authentication by verifying a Time-based One-Time Password (TOTP). Returns a session if validation is successful.
   * @summary Verify TOTP for MFA
   */
  const signInVerifyMfaTotp = async (
    signInMfaTotpRequest: SignInMfaTotpRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SessionPayload | ErrorResponse>> => {
    const res = await fetch(getSignInVerifyMfaTotpUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInMfaTotpRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: SessionPayload | ErrorResponse = body
      ? JSON.parse(body)
      : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<SessionPayload | ErrorResponse>;

    return response;
  };

  const getSignInVerifyMfaTotpUrl = () => {
    return baseURL + `/signin/mfa/totp`;
  };

  /**
   * Initiate passwordless authentication by sending a magic link to the user's email. If the user doesn't exist, a new account will be created with the provided options.
   * @summary Sign in with magic link email
   */
  const signInPasswordlessEmail = async (
    signInPasswordlessEmailRequest: SignInPasswordlessEmailRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getSignInPasswordlessEmailUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInPasswordlessEmailRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getSignInPasswordlessEmailUrl = () => {
    return baseURL + `/signin/passwordless/email`;
  };

  /**
   * Register a new user account with email and password. Returns a session if email verification is not required, otherwise returns null session.
   * @summary Sign up with email and password
   */
  const signUpEmailPassword = async (
    signUpEmailPasswordRequest: SignUpEmailPasswordRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SessionPayload | ErrorResponse>> => {
    const res = await fetch(getSignUpEmailPasswordUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signUpEmailPasswordRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: SessionPayload | ErrorResponse = body
      ? JSON.parse(body)
      : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<SessionPayload | ErrorResponse>;

    return response;
  };

  const getSignUpEmailPasswordUrl = () => {
    return baseURL + `/signup/email-password`;
  };

  /**
   * Activate or deactivate multi-factor authentication for the authenticated user
   * @summary Manage multi-factor authentication
   */
  const changeUserMfaVerify = async (
    userMfaRequest: UserMfaRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getChangeUserMfaVerifyUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(userMfaRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getChangeUserMfaVerifyUrl = () => {
    return baseURL + `/user/mfa`;
  };

  /**
   * Generate a Time-based One-Time Password (TOTP) secret for setting up multi-factor authentication
   * @summary Generate TOTP secret
   */
  const changeUserMfa = async (
    options?: RequestInit,
  ): Promise<FetchResponse<TotpGenerateResponse | ErrorResponse>> => {
    const res = await fetch(getChangeUserMfaUrl(), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: TotpGenerateResponse | ErrorResponse = body
      ? JSON.parse(body)
      : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<TotpGenerateResponse | ErrorResponse>;

    return response;
  };

  const getChangeUserMfaUrl = () => {
    return baseURL + `/mfa/totp/generate`;
  };

  /**
   * @summary Get public keys for JWT verification in JWK Set format
   */
  const getJWKs = async (
    options?: RequestInit,
  ): Promise<FetchResponse<JWKSet>> => {
    const res = await fetch(getGetJWKsUrl(), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: JWKSet = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<JWKSet>;

    return response;
  };

  const getGetJWKsUrl = () => {
    return baseURL + `/.well-known/jwks.json`;
  };

  /**
   * @summary Create a Personal Access Token (PAT)
   */
  const createPAT = async (
    createPATRequest: CreatePATRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<CreatePATResponse | ErrorResponse>> => {
    const res = await fetch(getCreatePATUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(createPATRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: CreatePATResponse | ErrorResponse = body
      ? JSON.parse(body)
      : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<CreatePATResponse | ErrorResponse>;

    return response;
  };

  const getCreatePATUrl = () => {
    return baseURL + `/pat`;
  };

  /**
   * @summary Sign in anonymously
   */
  const signInAnonymous = async (
    signinAnonymousRequest?: SigninAnonymousRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SessionPayload | ErrorResponse>> => {
    const res = await fetch(getSignInAnonymousUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signinAnonymousRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: SessionPayload | ErrorResponse = body
      ? JSON.parse(body)
      : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<SessionPayload | ErrorResponse>;

    return response;
  };

  const getSignInAnonymousUrl = () => {
    return baseURL + `/signin/anonymous`;
  };

  /**
   * @summary Sign in with a one time password sent to user's email. If the user doesn't exist, it will be created. The options object is optional and can be used to configure the user's when signing up a new user. It is ignored if the user already exists.
   */
  const signInOTPEmail = async (
    signInOTPEmailRequest: SignInOTPEmailRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getSignInOTPEmailUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInOTPEmailRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getSignInOTPEmailUrl = () => {
    return baseURL + `/signin/otp/email`;
  };

  /**
   * @summary Verify OTP and return a session if validation is successful
   */
  const verifySignInOTPEmail = async (
    signInOTPEmailVerifyRequest: SignInOTPEmailVerifyRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SignInOTPEmailVerifyResponse | ErrorResponse>> => {
    const res = await fetch(getVerifySignInOTPEmailUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInOTPEmailVerifyRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: SignInOTPEmailVerifyResponse | ErrorResponse = body
      ? JSON.parse(body)
      : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<SignInOTPEmailVerifyResponse | ErrorResponse>;

    return response;
  };

  const getVerifySignInOTPEmailUrl = () => {
    return baseURL + `/signin/otp/email/verify`;
  };

  /**
   * @summary Sign in with Personal Access Token (PAT)
   */
  const signInPAT = async (
    signInPATRequest: SignInPATRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SessionPayload | ErrorResponse>> => {
    const res = await fetch(getSignInPATUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInPATRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: SessionPayload | ErrorResponse = body
      ? JSON.parse(body)
      : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<SessionPayload | ErrorResponse>;

    return response;
  };

  const getSignInPATUrl = () => {
    return baseURL + `/signin/pat`;
  };

  /**
   * @summary Sign in with in an id token
   */
  const signInIdToken = async (
    signInIdTokenRequest: SignInIdTokenRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SessionPayload | ErrorResponse>> => {
    const res = await fetch(getSignInIdTokenUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInIdTokenRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: SessionPayload | ErrorResponse = body
      ? JSON.parse(body)
      : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<SessionPayload | ErrorResponse>;

    return response;
  };

  const getSignInIdTokenUrl = () => {
    return baseURL + `/signin/idtoken`;
  };

  /**
   * @summary Link a user account with the provider's account using an id token
   */
  const linkIdToken = async (
    linkIdTokenRequest: LinkIdTokenRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getLinkIdTokenUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(linkIdTokenRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getLinkIdTokenUrl = () => {
    return baseURL + `/link/idtoken`;
  };

  /**
   * @summary Deanonymize an anonymous user in adding missing email or email+password, depending on the chosen authentication method. Will send a confirmation email if the server is configured to do so
   */
  const deanonymizeUser = async (
    userDeanonymizeRequest: UserDeanonymizeRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getDeanonymizeUserUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(userDeanonymizeRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getDeanonymizeUserUrl = () => {
    return baseURL + `/user/deanonymize`;
  };

  /**
   * @summary Change user email
   */
  const changeUserEmail = async (
    userEmailChangeRequest: UserEmailChangeRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getChangeUserEmailUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(userEmailChangeRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getChangeUserEmailUrl = () => {
    return baseURL + `/user/email/change`;
  };

  /**
   * @summary Send verification email
   */
  const sendVerificationEmail = async (
    userEmailSendVerificationEmailRequest: UserEmailSendVerificationEmailRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getSendVerificationEmailUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(userEmailSendVerificationEmailRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getSendVerificationEmailUrl = () => {
    return baseURL + `/user/email/send-verification-email`;
  };

  /**
   * @summary Change user password. The user must be authenticated or provide a ticket
   */
  const changeUserPassword = async (
    userPasswordRequest: UserPasswordRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getChangeUserPasswordUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(userPasswordRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getChangeUserPasswordUrl = () => {
    return baseURL + `/user/password`;
  };

  /**
   * @summary Request a password reset. An email with a verification link will be sent to the user's address
   */
  const sendPasswordResetEmail = async (
    userPasswordResetRequest: UserPasswordResetRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse | ErrorResponse>> => {
    const res = await fetch(getSendPasswordResetEmailUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(userPasswordResetRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: OKResponse | ErrorResponse = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<OKResponse | ErrorResponse>;

    return response;
  };

  const getSendPasswordResetEmailUrl = () => {
    return baseURL + `/user/password/reset`;
  };

  /**
   * @summary Verify tickets created by email verification, email passwordless authentication (magic link), or password reset
   */
  const verifyTicket = async (
    params: VerifyTicketParams,
    options?: RequestInit,
  ): Promise<FetchResponse<void>> => {
    const res = await fetch(getVerifyTicketUrl(params), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const payload: void = body ? JSON.parse(body) : {};

    const response = {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<void>;

    return response;
  };

  const getVerifyTicketUrl = (params: VerifyTicketParams) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(
          key,
          value === null ? "null" : value.toString(),
        );
      }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
      ? baseURL + `/verify?${stringifiedParams}`
      : baseURL + `/verify`;
  };

  return {
    healthCheckHead,
    healthCheckGet,
    getVersion,
    refreshToken,
    signOut,
    signInEmailPassword,
    signInVerifyMfaTotp,
    signInPasswordlessEmail,
    signUpEmailPassword,
    changeUserMfaVerify,
    changeUserMfa,
    getJWKs,
    createPAT,
    signInAnonymous,
    signInOTPEmail,
    verifySignInOTPEmail,
    signInPAT,
    signInIdToken,
    linkIdToken,
    deanonymizeUser,
    changeUserEmail,
    sendVerificationEmail,
    changeUserPassword,
    sendPasswordResetEmail,
    verifyTicket,
    pushChainFunction,
    baseURL,
  };
};
