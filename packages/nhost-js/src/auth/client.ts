/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Nhost Authentication API
 * Comprehensive authentication service for managing user identities, sessions, and authentication methods
 * OpenAPI spec version: 1.0.0
 */
import { createEnhancedFetch } from "../fetch";
import type { ChainFunction } from "../fetch";

/**
 * JSON Web Key Set for verifying JWT signatures
 */
export interface JWKSet {
  /** Array of public keys */
  keys: Jwk[];
}

/**
 * JSON Web Key for JWT verification
 */
export interface Jwk {
  /** Algorithm used with this key */
  alg: string;
  /** RSA public exponent */
  e: string;
  /** Key ID */
  kid: string;
  /** Key type */
  kty: string;
  /** RSA modulus */
  n: string;
  /** Key usage */
  use: string;
}

/**
 * Request to refresh an access token
 */
export interface RefreshTokenRequest {
  /**
   * Refresh token used to generate a new access token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshToken: string;
}

export interface SignOutSchema {
  /** Refresh token for the current session */
  refreshToken: string;
  /** Sign out from all connected devices */
  all?: boolean;
}

export type CreatePATRequestMetadata = { [key: string]: unknown };

export interface CreatePATRequest {
  /** Expiration date of the PAT */
  expiresAt: string;
  metadata?: CreatePATRequestMetadata;
}

export interface CreatePATResponse {
  /**
   * ID of the PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  id: string;
  /**
   * PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  personalAccessToken: string;
}

/**
 * Error code identifying the specific application error
 */
export type ErrorResponseError =
  (typeof ErrorResponseError)[keyof typeof ErrorResponseError];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseError = {
  "default-role-must-be-in-allowed-roles":
    "default-role-must-be-in-allowed-roles",
  "disabled-endpoint": "disabled-endpoint",
  "disabled-user": "disabled-user",
  "email-already-in-use": "email-already-in-use",
  "email-already-verified": "email-already-verified",
  "forbidden-anonymous": "forbidden-anonymous",
  "internal-server-error": "internal-server-error",
  "invalid-email-password": "invalid-email-password",
  "invalid-request": "invalid-request",
  "locale-not-allowed": "locale-not-allowed",
  "password-too-short": "password-too-short",
  "password-in-hibp-database": "password-in-hibp-database",
  "redirectTo-not-allowed": "redirectTo-not-allowed",
  "role-not-allowed": "role-not-allowed",
  "signup-disabled": "signup-disabled",
  "unverified-user": "unverified-user",
  "user-not-anonymous": "user-not-anonymous",
  "invalid-pat": "invalid-pat",
  "invalid-refresh-token": "invalid-refresh-token",
  "invalid-ticket": "invalid-ticket",
  "disabled-mfa-totp": "disabled-mfa-totp",
  "no-totp-secret": "no-totp-secret",
  "invalid-totp": "invalid-totp",
  "mfa-type-not-found": "mfa-type-not-found",
  "totp-already-active": "totp-already-active",
} as const;

/**
 * Standardized error response
 */
export interface ErrorResponse {
  /** HTTP status error code */
  status: number;
  /** Human-friendly error message */
  message: string;
  /** Error code identifying the specific application error */
  error: ErrorResponseError;
}

/**
 * Response for email-password authentication that may include a session or MFA challenge
 */
export interface SignInEmailPasswordResponse {
  /** User session if authentication was successful. Null if MFA challenge is required. */
  session?: Session;
  /** MFA challenge if two-factor authentication is required */
  mfa?: MFAChallengePayload;
}

/**
 * Challenge payload for multi-factor authentication
 */
export interface MFAChallengePayload {
  /** Ticket to use when completing the MFA challenge */
  ticket: string;
}

/**
 * Container for session information
 */
export interface SessionPayload {
  /** User session data. Null if authentication requires additional steps. */
  session?: Session;
}

/**
 * User authentication session containing tokens and user information
 */
export interface Session {
  /** JWT token for authenticating API requests */
  accessToken: string;
  /** Expiration time of the access token in seconds */
  accessTokenExpiresIn: number;
  /**
   * Identifier for the refresh token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshTokenId: string;
  /**
   * Token used to refresh the access token
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  refreshToken: string;
  /** Information about the authenticated user */
  user?: User;
}

export interface SignInPATRequest {
  /**
   * PAT
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  personalAccessToken: string;
}

/**
 * Custom metadata associated with the user
 */
export type UserMetadata = { [key: string]: unknown };

/**
 * User profile and account information
 */
export interface User {
  /** URL to the user's profile picture */
  avatarUrl: string;
  /** Timestamp when the user account was created */
  createdAt: string;
  /** Default authorization role for the user */
  defaultRole: string;
  /** User's display name */
  displayName: string;
  /** User's email address */
  email?: string;
  /** Whether the user's email has been verified */
  emailVerified: boolean;
  /**
   * Unique identifier for the user
   * @pattern \b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b
   */
  id: string;
  /** Whether this is an anonymous user account */
  isAnonymous: boolean;
  /**
   * User's preferred locale (language code)
   * @minLength 2
   * @maxLength 2
   */
  locale: string;
  /** Custom metadata associated with the user */
  metadata: UserMetadata;
  /** User's phone number */
  phoneNumber?: string;
  /** Whether the user's phone number has been verified */
  phoneNumberVerified: boolean;
  /** List of roles assigned to the user */
  roles: string[];
}

/**
 * Which sign-in method to use
 */
export type UserDeanonymizeRequestSignInMethod =
  (typeof UserDeanonymizeRequestSignInMethod)[keyof typeof UserDeanonymizeRequestSignInMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserDeanonymizeRequestSignInMethod = {
  "email-password": "email-password",
  passwordless: "passwordless",
} as const;

export interface UserDeanonymizeRequest {
  /** Which sign-in method to use */
  signInMethod: UserDeanonymizeRequestSignInMethod;
  /** A valid email */
  email: string;
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  password?: string;
  /**
   * Deprecated, will be ignored
   * @deprecated
   */
  connection?: string;
  options?: SignUpOptions;
}

export interface UserEmailChangeRequest {
  /** A valid email */
  newEmail: string;
  options?: OptionsRedirectTo;
}

export interface UserEmailSendVerificationEmailRequest {
  /** A valid email */
  email: string;
  options?: OptionsRedirectTo;
}

export interface UserPasswordResetRequest {
  /** A valid email */
  email: string;
  options?: OptionsRedirectTo;
}

export interface UserPasswordRequest {
  /**
   * A password of minimum 3 characters
   * @minLength 3
   * @maxLength 50
   */
  newPassword: string;
  /**
   * Ticket to reset the password, required if the user is not authenticated
   * @pattern ^passwordReset\:.*$
   */
  ticket?: string;
}

export type OKResponse = (typeof OKResponse)[keyof typeof OKResponse];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OKResponse = {
  OK: "OK",
} as const;

export interface OptionsRedirectTo {
  redirectTo?: string;
}

export type SigninAnonymousRequestMetadata = { [key: string]: unknown };

export interface SigninAnonymousRequest {
  displayName?: string;
  /**
   * A two-characters locale
   * @minLength 2
   * @maxLength 2
   */
  locale?: string;
  metadata?: SigninAnonymousRequestMetadata;
}

/**
 * Request to authenticate using email and password
 */
export interface SignInEmailPasswordRequest {
  /** User's email address */
  email: string;
  /**
   * User's password
   * @minLength 3
   * @maxLength 50
   */
  password: string;
}

export interface SignInPasswordlessEmailRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInOTPEmailRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInOTPEmailVerifyRequest {
  /** One time password */
  otp: string;
  /** A valid email */
  email: string;
}

export interface SignInOTPEmailVerifyResponse {
  session?: Session;
}

/**
 * Request to register a new user with email and password
 */
export interface SignUpEmailPasswordRequest {
  /** Email address for the new user account */
  email: string;
  /**
   * Password for the new user account
   * @minLength 3
   * @maxLength 50
   */
  password: string;
  /** Optional configuration for the new user account */
  options?: SignUpOptions;
}

export type SignUpOptionsMetadata = { [key: string]: unknown };

export interface SignUpOptions {
  allowedRoles?: string[];
  defaultRole?: string;
  /**
   * @maxLength 32
   * @pattern ^[\p{L}\p{N}\p{S} ,.'-]+$
   */
  displayName?: string;
  /**
   * A two-characters locale
   * @minLength 2
   * @maxLength 2
   */
  locale?: string;
  metadata?: SignUpOptionsMetadata;
  redirectTo?: string;
}

export interface SignInWebauthnRequest {
  /** A valid email */
  email?: string;
}

export interface SignUpWebauthnRequest {
  /** A valid email */
  email: string;
  options?: SignUpOptions;
}

export interface SignInWebauthnResponse {
  [key: string]: unknown;
}

export interface SignUpWebauthnResponse {
  [key: string]: unknown;
}

export type SignInWebauthnVerifyRequestCredential = { [key: string]: unknown };

export interface SignInWebauthnVerifyRequest {
  /**
   * A valid email. Deprecated, no longer used
   * @deprecated
   */
  email?: string;
  credential: SignInWebauthnVerifyRequestCredential;
  [key: string]: unknown;
}

export type SignUpWebauthnVerifyRequestCredential = { [key: string]: unknown };

export type SignUpWebauthnVerifyRequestOptionsAllOf = {
  nickname?: string;
};

export type SignUpWebauthnVerifyRequestOptions = SignUpOptions &
  SignUpWebauthnVerifyRequestOptionsAllOf;

export interface SignUpWebauthnVerifyRequest {
  credential?: SignUpWebauthnVerifyRequestCredential;
  options?: SignUpWebauthnVerifyRequestOptions;
  [key: string]: unknown;
}

export interface SignInIdTokenRequest {
  provider: Provider;
  /** Apple ID token */
  idToken: string;
  /** Nonce used during sign in process */
  nonce?: string;
  options?: SignUpOptions;
}

export interface SignInMfaTotpRequest {
  /**
   * Ticket
   * @pattern ^mfaTotp:.*$
   */
  ticket: string;
  /** One time password */
  otp: string;
}

export type Provider = (typeof Provider)[keyof typeof Provider];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Provider = {
  apple: "apple",
  google: "google",
} as const;

export interface LinkIdTokenRequest {
  provider: Provider;
  /** Apple ID token */
  idToken: string;
  /** Nonce used during sign in process */
  nonce?: string;
}

/**
 * Type of MFA to activate. Use empty string to disable MFA.
 */
export type UserMfaRequestActiveMfaType =
  (typeof UserMfaRequestActiveMfaType)[keyof typeof UserMfaRequestActiveMfaType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserMfaRequestActiveMfaType = {
  totp: "totp",
  "": "",
} as const;

/**
 * Request to activate or deactivate multi-factor authentication
 */
export interface UserMfaRequest {
  /** Verification code from the authenticator app when activating MFA */
  code: string;
  /** Type of MFA to activate. Use empty string to disable MFA. */
  activeMfaType?: UserMfaRequestActiveMfaType;
}

/**
 * Response containing TOTP setup information for MFA
 */
export interface TotpGenerateResponse {
  /** URL to QR code image for scanning with an authenticator app */
  imageUrl: string;
  /** TOTP secret key for manual setup with an authenticator app */
  totpSecret: string;
}

/**
 * Ticket
 */
export type TicketQueryParameter = string;

/**
 * Type of the ticket
 */
export type TicketTypeQueryParameter =
  (typeof TicketTypeQueryParameter)[keyof typeof TicketTypeQueryParameter];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TicketTypeQueryParameter = {
  emailVerify: "emailVerify",
  emailConfirmChange: "emailConfirmChange",
  signinPasswordless: "signinPasswordless",
  passwordReset: "passwordReset",
} as const;

/**
 * Target URL for the redirect
 */
export type RedirectToQueryParameter = string;

export type GetVersion200 = {
  /** The version of the authentication service */
  version: string;
};

export type FetchResponse<T> = {
  data: T;
  status: number;
  headers: Record<string, string>;
};

export const createAPIClient = (
  baseURL: string,
  chainFunctions: ChainFunction[] = [],
) => {
  let fetch = createEnhancedFetch(chainFunctions);

  const pushChainFunction = (chainFunction: ChainFunction) => {
    chainFunctions.push(chainFunction);
    fetch = createEnhancedFetch(chainFunctions);
  };

  /**
   * Verify if the authentication service is operational using HEAD method
   * @summary Health check (HEAD)
   */
  const healthCheckHead = async (
    options?: RequestInit,
  ): Promise<FetchResponse<void>> => {
    const res = await fetch(getHealthCheckHeadUrl(), {
      ...options,
      method: "HEAD",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: void = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<void>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getHealthCheckHeadUrl = () => {
    return baseURL + `/healthz`;
  };

  /**
   * Verify if the authentication service is operational using GET method
   * @summary Health check (GET)
   */
  const healthCheckGet = async (
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse>> => {
    const res = await fetch(getHealthCheckGetUrl(), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: OKResponse = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<OKResponse>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getHealthCheckGetUrl = () => {
    return baseURL + `/healthz`;
  };

  /**
   * Retrieve version information about the authentication service
   * @summary Get service version
   */
  const getVersion = async (
    options?: RequestInit,
  ): Promise<FetchResponse<GetVersion200>> => {
    const res = await fetch(getGetVersionUrl(), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: GetVersion200 = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<GetVersion200>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getGetVersionUrl = () => {
    return baseURL + `/version`;
  };

  /**
   * Generate a new JWT access token using a valid refresh token. The refresh token used will be revoked and a new one will be issued.
   * @summary Refresh access token
   */
  const refreshToken = async (
    refreshTokenRequest: RefreshTokenRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<Session>> => {
    const res = await fetch(getRefreshTokenUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(refreshTokenRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: Session = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<Session>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getRefreshTokenUrl = () => {
    return baseURL + `/token`;
  };

  /**
   * @summary Sign out
   */
  const signOut = async (
    signOutSchema: SignOutSchema,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse>> => {
    const res = await fetch(getSignOutUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signOutSchema),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: OKResponse = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<OKResponse>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getSignOutUrl = () => {
    return baseURL + `/signout`;
  };

  /**
   * Authenticate a user with their email and password. Returns a session object or MFA challenge if two-factor authentication is enabled.
   * @summary Sign in with email and password
   */
  const signInEmailPassword = async (
    signInEmailPasswordRequest: SignInEmailPasswordRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SignInEmailPasswordResponse>> => {
    const res = await fetch(getSignInEmailPasswordUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInEmailPasswordRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: SignInEmailPasswordResponse = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<SignInEmailPasswordResponse>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getSignInEmailPasswordUrl = () => {
    return baseURL + `/signin/email-password`;
  };

  /**
   * Complete the multi-factor authentication by verifying a Time-based One-Time Password (TOTP). Returns a session if validation is successful.
   * @summary Verify TOTP for MFA
   */
  const signInVerifyMfaTotp = async (
    signInMfaTotpRequest: SignInMfaTotpRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SessionPayload>> => {
    const res = await fetch(getSignInVerifyMfaTotpUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInMfaTotpRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: SessionPayload = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<SessionPayload>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getSignInVerifyMfaTotpUrl = () => {
    return baseURL + `/signin/mfa/totp`;
  };

  /**
   * Initiate passwordless authentication by sending a magic link to the user's email. If the user doesn't exist, a new account will be created with the provided options.
   * @summary Sign in with magic link email
   */
  const signInPasswordlessEmail = async (
    signInPasswordlessEmailRequest: SignInPasswordlessEmailRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse>> => {
    const res = await fetch(getSignInPasswordlessEmailUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signInPasswordlessEmailRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: OKResponse = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<OKResponse>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getSignInPasswordlessEmailUrl = () => {
    return baseURL + `/signin/passwordless/email`;
  };

  /**
   * Register a new user account with email and password. Returns a session if email verification is not required, otherwise returns null session.
   * @summary Sign up with email and password
   */
  const signUpEmailPassword = async (
    signUpEmailPasswordRequest: SignUpEmailPasswordRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<SessionPayload>> => {
    const res = await fetch(getSignUpEmailPasswordUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(signUpEmailPasswordRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: SessionPayload = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<SessionPayload>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getSignUpEmailPasswordUrl = () => {
    return baseURL + `/signup/email-password`;
  };

  /**
   * Activate or deactivate multi-factor authentication for the authenticated user
   * @summary Manage multi-factor authentication
   */
  const changeUserMfaVerify = async (
    userMfaRequest: UserMfaRequest,
    options?: RequestInit,
  ): Promise<FetchResponse<OKResponse>> => {
    const res = await fetch(getChangeUserMfaVerifyUrl(), {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(userMfaRequest),
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: OKResponse = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<OKResponse>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getChangeUserMfaVerifyUrl = () => {
    return baseURL + `/user/mfa`;
  };

  /**
   * Generate a Time-based One-Time Password (TOTP) secret for setting up multi-factor authentication
   * @summary Generate TOTP secret
   */
  const changeUserMfa = async (
    options?: RequestInit,
  ): Promise<FetchResponse<TotpGenerateResponse>> => {
    const res = await fetch(getChangeUserMfaUrl(), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: TotpGenerateResponse = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<TotpGenerateResponse>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getChangeUserMfaUrl = () => {
    return baseURL + `/mfa/totp/generate`;
  };

  return {
    healthCheckHead,
    healthCheckGet,
    getVersion,
    refreshToken,
    signOut,
    signInEmailPassword,
    signInVerifyMfaTotp,
    signInPasswordlessEmail,
    signUpEmailPassword,
    changeUserMfaVerify,
    changeUserMfa,
    pushChainFunction,
    baseURL,
  };
};
