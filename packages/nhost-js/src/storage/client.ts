/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Nhost Storage API
 * Nhost Storage API - A service for managing and serving files with powerful access control capabilities
 * OpenAPI spec version: 1.0.0
 */
import { createEnhancedFetch } from "../fetch";
import type { ChainFunction } from "../fetch";

import type { Client } from "./interface";

/**
 * Contains version information about the storage service.
 */
export type VersionInformation = {
  /** The version number of the storage service build. */
  buildVersion?: string;
};

/**
 * Basic information about a file in storage.
 */
export type FileSummary = {
  /** Unique identifier for the file. */
  id?: string;
  /** Name of the file including extension. */
  name?: string;
  /** ID of the bucket containing the file. */
  bucketId?: string;
  /** Whether the file has been successfully uploaded. */
  isUploaded?: boolean;
};

/**
 * Custom metadata associated with the file.
 */
export type FileMetadataMetadata = { [key: string]: unknown };

/**
 * Comprehensive metadata information about a file in storage.
 */
export type FileMetadata = {
  /** Unique identifier for the file. */
  id?: string;
  /** Name of the file including extension. */
  name?: string;
  /** Size of the file in bytes. */
  size?: number;
  /** ID of the bucket containing the file. */
  bucketId?: string;
  /** Entity tag for cache validation. */
  etag?: string;
  /** Timestamp when the file was created. */
  createdAt?: string;
  /** Timestamp when the file was last updated. */
  updatedAt?: string;
  /** Whether the file has been successfully uploaded. */
  isUploaded?: boolean;
  /** MIME type of the file. */
  mimeType?: string;
  /** ID of the user who uploaded the file. */
  uploadedByUserId?: string;
  /** Custom metadata associated with the file. */
  metadata?: FileMetadataMetadata;
};

/**
 * Custom metadata to associate with the file.
 */
export type UploadFileMetadataMetadata = { [key: string]: unknown };

/**
 * Metadata provided when uploading a new file.
 */
export type UploadFileMetadata = {
  /** Optional custom ID for the file. If not provided, a UUID will be generated. */
  id?: string;
  /** Name to assign to the file. If not provided, the original filename will be used. */
  name?: string;
  /** Custom metadata to associate with the file. */
  metadata?: UploadFileMetadataMetadata;
};

/**
 * Updated custom metadata to associate with the file.
 */
export type UpdateFileMetadataMetadata = { [key: string]: unknown };

/**
 * Metadata that can be updated for an existing file.
 */
export type UpdateFileMetadata = {
  /** New name to assign to the file. */
  name?: string;
  /** Updated custom metadata to associate with the file. */
  metadata?: UpdateFileMetadataMetadata;
};

/**
 * Contains a presigned URL for direct file operations.
 */
export type PresignedURLResponse = {
  /** The presigned URL for file operations. */
  url?: string;
  /** The time in seconds until the URL expires. */
  expiration?: number;
};

/**
 * Error details.
 */
export type ErrorError = {
  /** Human-readable error message. */
  message: string;
};

/**
 * Error information returned by the API.
 */
export type Error = {
  /** Error details. */
  error?: ErrorError;
};

export type GetOpenAPISpec200 = { [key: string]: unknown };

export type UploadFilesBody = {
  /** Target bucket identifier where files will be stored. */
  "bucket-id"?: string;
  /** Optional custom metadata for each uploaded file. Must match the order of the file[] array. */
  "metadata[]"?: UploadFileMetadata[];
  /** Array of files to upload. */
  "file[]"?: Blob[];
};

export type UploadFiles201 = {
  /** List of successfully processed files with their metadata. */
  processedFiles?: FileMetadata[];
};

export type GetFileMetadataHeadersParams = {
  /**
   * Image quality (1-100). Only applies to JPEG, WebP and PNG files
   */
  q?: number;
  /**
   * Maximum height to resize image to while maintaining aspect ratio. Only applies to image files
   */
  h?: number;
  /**
   * Maximum width to resize image to while maintaining aspect ratio. Only applies to image files
   */
  w?: number;
  /**
   * Blur the image using this sigma value. Only applies to image files
   */
  b?: number;
  /**
   * Output format for image files. Use 'auto' for content negotiation based on Accept header
   */
  f?: GetFileMetadataHeadersF;
};

export type GetFileMetadataHeadersF =
  | "auto"
  | "same"
  | "jpeg"
  | "webp"
  | "png"
  | "avif";
export type GetFileParams = {
  /**
   * Image quality (1-100). Only applies to JPEG, WebP and PNG files
   */
  q?: number;
  /**
   * Maximum height to resize image to while maintaining aspect ratio. Only applies to image files
   */
  h?: number;
  /**
   * Maximum width to resize image to while maintaining aspect ratio. Only applies to image files
   */
  w?: number;
  /**
   * Blur the image using this sigma value. Only applies to image files
   */
  b?: number;
  /**
   * Output format for image files. Use 'auto' for content negotiation based on Accept header
   */
  f?: GetFileF;
};

export type GetFileF = "auto" | "same" | "jpeg" | "webp" | "png" | "avif";
export type ReplaceFileBody = {
  /** Optional metadata to update for the file */
  metadata?: UpdateFileMetadata;
  /** New file content to replace the existing file */
  file?: Blob;
};

export type FetchResponse<T> = {
  data: T;
  status: number;
  headers: Record<string, string>;
};

export const createAPIClient = (
  baseURL: string,
  chainFunctions: ChainFunction[] = [],
): Client => {
  let fetch = createEnhancedFetch(chainFunctions);

  const pushChainFunction = (chainFunction: ChainFunction) => {
    chainFunctions.push(chainFunction);
    fetch = createEnhancedFetch(chainFunctions);
  };

  /**
   * Returns the OpenAPI schema definition for this API, allowing clients to understand the available endpoints and models.
   * @summary Get OpenAPI specification
   */
  const getOpenAPISpec = async (
    options?: RequestInit,
  ): Promise<FetchResponse<GetOpenAPISpec200>> => {
    const res = await fetch(getGetOpenAPISpecUrl(), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: GetOpenAPISpec200 = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<GetOpenAPISpec200>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getGetOpenAPISpecUrl = () => {
    return baseURL + `/openapi.yaml`;
  };

  /**
   * Retrieves build and version information about the storage service. Useful for monitoring and debugging.
   * @summary Get service version information
   */
  const getVersion = async (
    options?: RequestInit,
  ): Promise<FetchResponse<VersionInformation>> => {
    const res = await fetch(getGetVersionUrl(), {
      ...options,
      method: "GET",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: VersionInformation = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<VersionInformation>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getGetVersionUrl = () => {
    return baseURL + `/version`;
  };

  /**
   * Upload one or more files to a specified bucket. Supports batch uploading with optional custom metadata for each file. If uploading multiple files, either provide metadata for all files or none.
   * @summary Upload files
   */
  const uploadFiles = async (
    uploadFilesBody: UploadFilesBody,
    options?: RequestInit,
  ): Promise<FetchResponse<UploadFiles201>> => {
    const formData = new FormData();
    if (uploadFilesBody["bucket-id"] !== undefined) {
      formData.append(`bucket-id`, uploadFilesBody["bucket-id"]);
    }
    if (uploadFilesBody["metadata[]"] !== undefined) {
      uploadFilesBody["metadata[]"].forEach((value) =>
        formData.append(`metadata[]`, JSON.stringify(value)),
      );
    }
    if (uploadFilesBody["file[]"] !== undefined) {
      uploadFilesBody["file[]"].forEach((value) =>
        formData.append(`file[]`, value),
      );
    }

    const res = await fetch(getUploadFilesUrl(), {
      ...options,
      method: "POST",
      body: formData,
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: UploadFiles201 = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<UploadFiles201>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getUploadFilesUrl = () => {
    return baseURL + `/files/`;
  };

  /**
   * Retrieve file metadata headers without downloading the file content. Supports conditional requests and provides caching information.
   * @summary Check file information
   */
  const getFileMetadataHeaders = async (
    id: string,
    params?: GetFileMetadataHeadersParams,
    options?: RequestInit,
  ): Promise<FetchResponse<void>> => {
    const res = await fetch(getGetFileMetadataHeadersUrl(id, params), {
      ...options,
      method: "HEAD",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: void = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<void>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getGetFileMetadataHeadersUrl = (
    id: string,
    params?: GetFileMetadataHeadersParams,
  ) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(
          key,
          value === null ? "null" : value.toString(),
        );
      }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
      ? baseURL + `/files/${id}?${stringifiedParams}`
      : baseURL + `/files/${id}`;
  };

  /**
   * Retrieve and download the complete file content. Supports conditional requests, image transformations, and range requests for partial downloads.
   * @summary Download file
   */
  const getFile = async (
    id: string,
    params?: GetFileParams,
    options?: RequestInit,
  ): Promise<FetchResponse<Blob>> => {
    const res = await fetch(getGetFileUrl(id, params), {
      ...options,
      method: "GET",
    });

    const data: Blob = await res.blob();

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<Blob>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getGetFileUrl = (id: string, params?: GetFileParams) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(
          key,
          value === null ? "null" : value.toString(),
        );
      }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
      ? baseURL + `/files/${id}?${stringifiedParams}`
      : baseURL + `/files/${id}`;
  };

  /**
 * Replace an existing file with new content while preserving the file ID. The operation follows these steps:
1. The isUploaded flag is set to false to mark the file as being updated
2. The file content is replaced in the storage backend
3. File metadata is updated (size, mime-type, isUploaded, etc.)

Each step is atomic, but if a step fails, previous steps will not be automatically rolled back.

 * @summary Replace file
 */
  const replaceFile = async (
    id: string,
    replaceFileBody: ReplaceFileBody,
    options?: RequestInit,
  ): Promise<FetchResponse<FileMetadata>> => {
    const formData = new FormData();
    if (replaceFileBody.metadata !== undefined) {
      formData.append(`metadata`, JSON.stringify(replaceFileBody.metadata));
    }
    if (replaceFileBody.file !== undefined) {
      formData.append(`file`, replaceFileBody.file);
    }

    const res = await fetch(getReplaceFileUrl(id), {
      ...options,
      method: "PUT",
      body: formData,
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: FileMetadata = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<FileMetadata>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getReplaceFileUrl = (id: string) => {
    return baseURL + `/files/${id}`;
  };

  /**
   * Permanently delete a file from storage. This removes both the file content and its associated metadata.
   * @summary Delete file
   */
  const deleteFile = async (
    id: string,
    options?: RequestInit,
  ): Promise<FetchResponse<void>> => {
    const res = await fetch(getDeleteFileUrl(id), {
      ...options,
      method: "DELETE",
    });

    const body = [204, 205, 304, 412].includes(res.status)
      ? null
      : await res.text();
    const data: void = body ? JSON.parse(body) : {};

    const response = {
      data,
      status: res.status,
      headers: Object.fromEntries(Array.from((res.headers as any).entries())),
    } as FetchResponse<void>;

    if (!res.ok) {
      throw response;
    }

    return response;
  };

  const getDeleteFileUrl = (id: string) => {
    return baseURL + `/files/${id}`;
  };

  return {
    getOpenAPISpec,
    getVersion,
    uploadFiles,
    getFileMetadataHeaders,
    getFile,
    replaceFile,
    deleteFile,
    pushChainFunction,
    baseURL,
  };
};
