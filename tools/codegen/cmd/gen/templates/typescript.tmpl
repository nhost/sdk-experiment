/**
 * This file is auto-generated. Do not edit manually.
 */
import { FetchError, createEnhancedFetch } from "../fetch";
import type { ChainFunction, FetchResponse } from "../fetch";

import type { Client } from "./interface";


function objectToFormData(obj?: Record<string, any>): FormData {
  const formData = new FormData();

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const value = obj[key];

      // Check if the value is undefined
      if (value !== undefined) {
        if (Array.isArray(value)) {
          // Handle arrays by appending each item
          value.forEach((item) => {
            if (item instanceof Blob || item instanceof File) {
              // Append Blob or File directly
              formData.append(key, item);
            } else if (typeof item === 'object' && item !== null) {
              // Serialize object to JSON string
              formData.append(key, JSON.stringify(item));
            } else {
              // Append primitive values directly
              formData.append(key, item);
            }
          });
        } else if (value instanceof Blob || value instanceof File) {
          // Append Blob or File directly
          formData.append(key, value);
        } else if (typeof value === 'object' && value !== null) {
          // Serialize single object to JSON string
          formData.append(key, JSON.stringify(value));
        } else {
          // Append primitive values directly
          formData.append(key, value);
        }
      }
    }
  }

  return formData;
}


{{- define "renderMethod" }}
  /**
   * {{ .Summary }}
   *
   * {{ .Description }}
   */
  const {{ .Name }} = async (
      {{ range .PathParameters }}
      {{ .Name }}: {{ .Type }},
      {{- end }}
      {{- if not .RequestIsEmpty }}
      {{ .ArgumentName }}{{ if not .ArgumentRequired }}?{{ end }}: {{ .ArgumentType }},
      {{- end }}
      {{- if .HasQueryParameters }}
      params{{ if not .QueryParametersRequired }}?{{ end }}: {{ ToCamelCase .Name }}Params,
      {{- end }}
      options?: RequestInit,
  ): Promise<FetchResponse<{{ .ReturnType }}>> => {
    {{- if .HasQueryParameters }}
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(
          key,
          value === null ? "null" : value.toString(),
        );
      }
    });

    const stringifiedParams = normalizedParams.toString();

    const url = stringifiedParams.length > 0
      ? baseURL + `{{ .Path }}?${stringifiedParams}`
      : baseURL + `{{ .Path }}`;

    {{- else }}
    const url = baseURL + `{{ .Path }}`;
    {{- end }}
    const res = await fetch(url, {
      ...options,
      method: "{{ .Method }}",
      {{- if .RequestIsJSON }}
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify({{ .ArgumentName }}),
      {{- else if .RequestIsMultipart }}
      body: objectToFormData({{ .ArgumentName }}),
      {{- else if .RequestIsEmpty }}
      {{- else }}
      UNSUPPORTED
      {{- end }}
    });

    if (res.status >= 400) {
      const body = [412].includes(res.status) ? null : await res.text();
      const payload: unknown = body ? JSON.parse(body) : {};
      throw new FetchError(payload, res.status, res.headers);
    }

    {{- if eq .ReturnType "Blob" }}
    const payload: Blob = await res.blob();
    {{- else }}
    const body = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload: {{ .ReturnType }} = body ? JSON.parse(body) : {};
    {{- end }}

    return {
      body: payload,
      status: res.status,
      headers: res.headers,
    } as FetchResponse<{{ .ReturnType }}>;
  };
{{- end -}}

{{- define "renderMethodRedirect" }}
  /**
   * {{ .Summary }}
   *
   * {{ .Description }}
   */
  const {{ .Name }} = (
      {{ range .PathParameters }}
      {{ .Name }}: string,
      {{- end }}
      {{- if .HasQueryParameters }}
      params{{ if not .QueryParametersRequired }}?{{ end }}: {{ ToCamelCase .Name }}Params,
      {{- end }}
  ): string => {
    {{- if .HasQueryParameters }}
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(
          key,
          value === null ? "null" : value.toString(),
        );
      }
    });

    const stringifiedParams = normalizedParams.toString();

    const url = stringifiedParams.length > 0
      ? baseURL + `{{ .Path }}?${stringifiedParams}`
      : baseURL + `{{ .Path }}`;

    {{- end }}
    return url;
  };
{{- end -}}

{{ define "renderObjectAttributeHelp" -}}
  {{ .Schema.Description }}
  {{- if .Example }}
    *    Example - {{ .Example }}
  {{- end }}
  {{- if .Schema.Pattern }}
    *    Pattern - {{ .Schema.Pattern }}
  {{- end }}
  {{- if .Format }}
    *    Format - {{ .Format }}
  {{- end }}
  {{- if .MinLength }}
    *    MinLength - {{ .MinLength }}
  {{- end }}
  {{- if .MaxLength }}
    *    MaxLength - {{ .MaxLength }}
  {{- end }}
{{- end -}}

{{- define "renderObject" }}
/**
 * {{ .Schema.Description }}
{{- range .Properties }}
 * @property {{ .Name }} - {{ template "renderObjectAttributeHelp" . }}
 {{- end -}}
 */
export interface {{ .Name }} {
  {{- range .Properties }}
  /**
   *{{ template "renderObjectAttributeHelp" . }}
   */
  {{ .Name }}{{ if not .IsRequired }}?{{ end}}: {{ .Type }};
  {{- end }}
};
{{ end }}

{{- define "union" }}
export type {{ .Name }} = {{ range .Union }}{{ . }} & {{ end }}{};
{{- end }}


{{- define "renderEnum" }}
/**
 * {{ .Schema.Description }}
 */
export enum {{ .Name }} {
{{- range .Enum }}
  {{ ToCamelCase .Name }} = "{{ .Value }}",
{{- end }}
};
{{- end }}

{{- range .Types }}
{{ if .IsUnion }}
{{ template "union" . }}
{{ else if .IsObject }}
{{ template "renderObject" . }}
{{ else if .IsEnum }}
{{ template "renderEnum" . }}
{{ else if .IsUnion }}
{{ else }}
!!!!!!!!!!!! {{ .Name }} is not supported !!!!!!!!!!!!
{{ end }}
{{- end }}

{{- range .Methods }}
{{ if .HasQueryParameters }}
export interface {{ ToCamelCase .Name }}Params {
{{- range .QueryParameters }}
  {{ .Name }}{{ if not .Required }}?{{ end }}: {{ .Type }};
{{- end }}
};
{{- end }}
{{- end }}

export const createAPIClient = (
  baseURL: string,
  chainFunctions: ChainFunction[] = [],
): Client => {
  let fetch = createEnhancedFetch(chainFunctions);

  const pushChainFunction = (chainFunction: ChainFunction) => {
    chainFunctions.push(chainFunction);
    fetch = createEnhancedFetch(chainFunctions);
  };

{{- range .Methods }}
{{ if .IsRedirect }}
  {{ template "renderMethodRedirect" . }}
{{ else }}
  {{ template "renderMethod" . }}
{{ end }}
{{- end }}

  return {
{{- range .Methods }}
    {{ .Name }},
{{- end }}
    baseURL,
    pushChainFunction,
  };
}
